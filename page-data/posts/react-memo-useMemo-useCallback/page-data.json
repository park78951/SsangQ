{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/react-memo-useMemo-useCallback","result":{"data":{"markdownRemark":{"id":"57217996-4c87-5477-9476-f206619dc99f","html":"<p>React 최적화를 공부하면서 <code class=\"language-text\">useMemo, useCallback, React.memo</code>를 접했다. <code class=\"language-text\">useMemo</code>와 <code class=\"language-text\">useCallback</code>은 실제로 Todo Application에 적용해 봤지만, 일단 최적화 시도를 위한 API 사용을 해본 것일 뿐 정확하게 어떻게 최적화가 되는지에 대해서는 알지 못했다. 이번 기회에 <code class=\"language-text\">useMemo</code>와 <code class=\"language-text\">useCallback, React.mem</code>o가 어떻게 최적화가 되는지 학습하여 정리하려고 한다.</p>\n<h2 id=\"최적화에-사용되는-memoization\"><a href=\"#%EC%B5%9C%EC%A0%81%ED%99%94%EC%97%90-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-memoization\" aria-label=\"최적화에 사용되는 memoization permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최적화에 사용되는 Memoization</h2>\n<p>Memoization이란 <code class=\"language-text\">이전 값을 메모리에 저장해 동일한 계산의 반복을 제거해 빠른 처리를 가능하게 하는 기술</code> 이라고 한다. useMemo, useCallback, React.memo는 모두 이 <code class=\"language-text\">Memoization</code>을 기반으로 작동한다. 그럼 이 <code class=\"language-text\">Memoization</code>이 어떻게 사용되는지 확인해보자.</p>\n<h2 id=\"reactmemo\"><a href=\"#reactmemo\" aria-label=\"reactmemo permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React.memo</h2>\n<h3 id=\"reactmemo의-특징과-사용\"><a href=\"#reactmemo%EC%9D%98-%ED%8A%B9%EC%A7%95%EA%B3%BC-%EC%82%AC%EC%9A%A9\" aria-label=\"reactmemo의 특징과 사용 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React.memo의 특징과 사용</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const Welcome = ({ name }) =&gt; {\n  return &lt;h1&gt;Hello { name }&lt;/h1&gt;;\n};\n\nexport default React.memo(Welcome);</code></pre></div>\n<p>React.memo는 일반적으로 위와 같이 사용되며 직접 함수를 감싸서 사용하기도 한다. React.memo는 Welcome의 결과를 Memoization해서 이후 props가 변경될때까지 현재 memoized된 내용을 그대로 사용하여 리렌더링을 막는다. 이렇게 Memoized된 내용을 재사용하여 렌더링시 가상 DOM에서 달라진 부분을 확인하지 않아 성능상의 이점이 생기게 된다.</p>\n<p>React.memo가 props나 props의 객체를 비교할 때 얕은 비교를 진행하는데, 얕은 비교란 원시 값의 경우는 같은 값을 갖는지 확인하고 객체나 배열과 같은 참조 값은 같은 주소 값을 갖고 있는지 확인한다.</p>\n<p>React.memo 메서드는 <code class=\"language-text\">React.memo(component, compFunc)</code>와 같은 형태가 기본 형태인데, <code class=\"language-text\">compFunc</code> 부분에는 내가 수동으로 비교방식을 수정할 수 있다. 하지만 사용해보지는 않았다.</p>\n<h3 id=\"reactmemo를-언제-써야-할까\"><a href=\"#reactmemo%EB%A5%BC-%EC%96%B8%EC%A0%9C-%EC%8D%A8%EC%95%BC-%ED%95%A0%EA%B9%8C\" aria-label=\"reactmemo를 언제 써야 할까 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React.memo를 언제 써야 할까?</h3>\n<p>이러한 React 최적화 방식들을 공부하면서 접했던 내용은 React.memo의 내부 동작 원리보다는 무조건 적인 사용을 지양하라는 것이었다. 그 이유는 최적화를 위한 연산이 불필요한 경우엔 비용만 발생시키기 때문이다. React.memo는 다음과 같은 상황에서 사용을 권장한다.</p>\n<ol>\n<li>Pure Functional Component에서</li>\n<li>Rendering이 자주일어날 경우</li>\n<li>re-rendering이 되는 동안에도 계속 같은 props값이 전달될 경우</li>\n<li>UI element의 양이 많은 컴포넌트의 경우</li>\n</ol>\n<p>일반적으로 불필요한 Render가 많이 발생하는 곳에서 사용하라는 말과 같다. 개인적으로 Todo Web application을 진행하면서 부모 컴포넌트가 자주 rendering될 때마다 자식 컴포넌트가 쓸데없이 함께 렌더링 되는 경우를 겪은 적이 있는데, 이 때 React.memo를 사용해 rendering을 막은 것을 React dev tool로 확인했던 것이 기억에 남는다.</p>\n<h3 id=\"reactmemo를-사용하지-말아야-할-경우는\"><a href=\"#reactmemo%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%90%EC%95%84%EC%95%BC-%ED%95%A0-%EA%B2%BD%EC%9A%B0%EB%8A%94\" aria-label=\"reactmemo를 사용하지 말아야 할 경우는 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React.memo를 사용하지 말아야 할 경우는?</h3>\n<p>위의 경우를 제외하면 사용하지 않는 것을 권장하지만, 일반적으로 class 기반의 컴포넌트를 래핑하는 것도 적절하지 않은 사용으로 설명된다. 이 경우 memoization을 해야겠다면, PureComponent를 확장하여 사용하거나 <code class=\"language-text\">shouldComponentUpdate()</code>를 사용하길 권장하고있다.</p>\n<h3 id=\"reactmemo의-주의-사항---부모가-전달하는-callback-함수\"><a href=\"#reactmemo%EC%9D%98-%EC%A3%BC%EC%9D%98-%EC%82%AC%ED%95%AD---%EB%B6%80%EB%AA%A8%EA%B0%80-%EC%A0%84%EB%8B%AC%ED%95%98%EB%8A%94-callback-%ED%95%A8%EC%88%98\" aria-label=\"reactmemo의 주의 사항   부모가 전달하는 callback 함수 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React.memo의 주의 사항 - 부모가 전달하는 callback 함수</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function MyApp({ store, cookies }) {\n  return (\n    &lt;div className=&quot;main&quot;&gt;\n      &lt;header&gt;\n        &lt;MemoizedLogout\n          username={store.username}\n          onLogout={() =&gt; cookies.clear()}\n        /&gt;\n      &lt;/header&gt;\n      {store.content}\n    &lt;/div&gt;\n  );\n}</code></pre></div>\n<p>위와 같은 MyApp component의 경우 <code class=\"language-text\">&lt;MemoizedLogout /&gt;</code>컴포넌트는 onLogout과 username이란 두개의 props를 전달받게 된다. MemoizedLogout이 React.memo로 래핑된 함수 컴포넌트라고 할 때, MyApp이 re-rendering 되더라도 MemoizedLogout에 전달되는 props값이 동일하다면 MemoizedLogout component는 re-rendering을 피할 수 있을까? 정답은 아니라고 한다.</p>\n<p>onLogout의 callback 함수는 MyApp이 re-rendring이 될 때마다 새로운 참조값을 갖게 될 것이다. 함수의 내용은 같더라도 주소 값이 다르다면 MemoizedLogout은 re-rendering이 발생할 것이고, React.memo는 오히려 쓸데없는 메모리만 낭비하는 것이다.\n이를 위해 useCallback을 통해 callback 함수를 동일한 callback 인스턴스로 설정한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const MemoizedLogout = React.memo(Logout);\n\nfunction MyApp({ store, cookies }) {\n  const onLogout = useCallback(() =&gt; {\n    cookies.clear();\n  }, []);\n// ...</code></pre></div>\n<p>항상 같은 함수 인스턴스를 반환하기 때문에 MemoizedLogout의 React.memo가 정상 기능을 수행한다.</p>\n<h2 id=\"usememo--usecallback\"><a href=\"#usememo--usecallback\" aria-label=\"usememo  usecallback permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useMemo &#x26; useCallback</h2>\n<p><strong>useMemo</strong>는? 사용방법을 제외하고는 React.memo와 매우 흡사하다. React.memo가 component의 결과 값을 memoized하여 불필요한 re-rendering을 관리한다면, useMemo는 함수의 결과 값을 memoized하여 불필요한 연산을 관리한다. 아래 코드를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);\nconst memoizedValue = useCallback(computeExpensiveValue(a, b), [a, b]); // 위와 동일</code></pre></div>\n<p>useMemo의 특징은 일단 함수 호출 이후의 return 값이 memoized되며, 두 번째 파라미터의 배열 내부 값이 변경될 때마다 첫 번째 파라미터의 callback 함수를 실행시키는 구조다. useCallback을 사용해도 useMemo의 대체형태로 사용 할 수 있다고 하는데, useCallback은 아래에서 정리하겠다.</p>\n<p><strong>useCallback</strong>은 useMemo와 흡사하지만, 일반적으로 함수를 memoized하며, 아래와 같이 사용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const handleChange = useCallback(e =&gt; {\n    setNum(e.target.value);\n  }, []);</code></pre></div>\n<p>useCallback을 통해 memoized된 함수는 예를 들어 event handler로 사용되며, 마찬가지로 2번째 인자가 변경될 때마다 함수가 다시 memoized된다.</p>\n<h3 id=\"usecallback의-예시\"><a href=\"#usecallback%EC%9D%98-%EC%98%88%EC%8B%9C\" aria-label=\"usecallback의 예시 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useCallback의 예시</h3>\n<p><em>useCallback 사용 전</em></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function CountButton({ onClick, count }) {\n  return &lt;button onClick={onClick}&gt;{count}&lt;/button&gt;;\n}\nfunction DualCounter() {\n  const [count1, setCount1] = React.useState(0);\n  const increment1 = () =&gt; setCount1(c =&gt; c + 1);\n  const [count2, setCount2] = React.useState(0);\n  const increment2 = () =&gt; setCount2(c =&gt; c + 1);\n  return (\n    &lt;&gt;\n      &lt;CountButton count={count1} onClick={increment1} /&gt;\n      &lt;CountButton count={count2} onClick={increment2} /&gt;\n    &lt;/&gt;\n  );\n}</code></pre></div>\n<p><em>useCallback 사용 후</em></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const CountButton = React.memo(function CountButton({ onClick, count }) {\n  return &lt;button onClick={onClick}&gt;{count}&lt;/button&gt;;\n});\nfunction DualCounter() {\n  const [count1, setCount1] = React.useState(0);\n  const increment1 = React.useCallback(() =&gt; setCount1(c =&gt; c + 1), []);\n  const [count2, setCount2] = React.useState(0);\n  const increment2 = React.useCallback(() =&gt; setCount2(c =&gt; c + 1), []);\n  return (\n    &lt;&gt;\n      &lt;CountButton count={count1} onClick={increment1} /&gt; // React.memo로 래핑되었다는 가정\n      &lt;CountButton count={count2} onClick={increment2} /&gt; // React.memo로 래핑되었다는 가정\n    &lt;/&gt;\n  );\n}</code></pre></div>\n<p>useCallback을 사용하여 count1이나 count2 둘 중 하나의 state만 변경되었음에도 2개의 CountButton이 re-rendering되는 것을 막아 최적화를 이뤘다.</p>\n<h2 id=\"최적화에-대한-생각\"><a href=\"#%EC%B5%9C%EC%A0%81%ED%99%94%EC%97%90-%EB%8C%80%ED%95%9C-%EC%83%9D%EA%B0%81\" aria-label=\"최적화에 대한 생각 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최적화에 대한 생각</h2>\n<p>실제로 React Dev Tools를 통해 불필요한 re-rendering을 막는 것을 보니 굉장히 유용한 API라는 생각과 함께 적극적으로 사용해야겠다고 생각한다. 하지만, 아직 React에 대한 숙련도가 높지 않은 만큼 높은 레벨의 기술일 수록 더욱 신중하고 조심히 써야한다고 생각한다. 위에 정리했던 대로 최적화를 위한 코드가 잘못 사용되면 부담을 가중시키는 코드로 변질될 수 있으니, 앞으로 원리를 더 이해하고 경험을 쌓아가며 좋은 코드를 작성하기 위한 고민을 해야겠다.</p>\n<h2 id=\"도움받은-블로그\"><a href=\"#%EB%8F%84%EC%9B%80%EB%B0%9B%EC%9D%80-%EB%B8%94%EB%A1%9C%EA%B7%B8\" aria-label=\"도움받은 블로그 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>도움받은 블로그</h2>\n<p><a href=\"https://ui.toast.com/weekly-pick/ko_20190731/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TOAST UI</a><br>\n<a href=\"https://kentcdodds.com/blog/usememo-and-usecallback\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Kent C. Dodds</a>  </p>\n<hr>\n<blockquote>\n<p>공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.</p>\n</blockquote>\n<hr>","fields":{"slug":"/posts/react-memo-useMemo-useCallback","tagSlugs":["/tag/es-6/","/tag/react/","/tag/hooks/","/tag/javascript/","/tag/front-end/","/tag/react-optimization/","/tag/hooks-optimization/"]},"frontmatter":{"date":"2019-10-03T21:12:22.000Z","description":"React Todo Web Application을 만들면서 시도해봤던 최적화 중 useMemo와 useCallback, 그리고 그와 비슷한 React.memo에 대한 정리를 하고자한다.","tags":["ES6","React","Hooks","Javascript","Front-end","React Optimization","Hooks Optimization"],"title":"React 최적화, useMemo, useCallback, React.memo","socialImage":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/react-memo-useMemo-useCallback"}}}