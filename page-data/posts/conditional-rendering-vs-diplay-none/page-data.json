{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/conditional-rendering-vs-diplay-none","result":{"data":{"markdownRemark":{"id":"97861ccf-5ab1-5a42-9eaf-25e567267d53","html":"<p>현재 프로젝트를 진행하면서 검색 필터링 기능을 구현하고있다. 구현하다보니 필터링 주제별로 <strong><em>4가지의 버튼</em></strong>이 있고, 이 버튼에 따라 같은 형태의 내용만 다른 <strong><em>메뉴 컴포넌트</em></strong>를 렌더링해야할 필요가 있었다. 최초 설계 했을 때와 다르게 코드를 작성하면서 변경할 필요성을 느낀점과 새롭게 알게된 점에 대해 정리하고자 한다.</p>\n<h2 id=\"display-none\"><a href=\"#display-none\" aria-label=\"display none permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>display: none</h2>\n<p>처음 설계하면서부터 컴포넌트를 flag 변경에 따라 styled-components에 변수로 전달해 display none을 하는 방식으로 렌더링을 진행했다. 하지만 React Dev Tools로 확인했을 때, 컴포넌트가 새롭게 렌더링 될 때마다 하위 요소들이 전부 새롭게 렌더링 되는 점을 발견했다. 성능에는 눈에 띌 정도로 문제가 발생하지는 않지만, 최적화 측면에서 좋지 않다는 것을 확실히 알 수 있었다.</p>\n<p>위에 설명한 부부을 아래 사진으로 확인 할 수 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/37759759/69438877-2de6c300-0d89-11ea-8ad4-c7f445ee3ba1.gif\" alt=\"2019-11-22-22-45-57\"></p>\n<p>화살표 버튼으로 해당 필터 메뉴를 Toggle 했을 땐 필터 메뉴의 상위 컴포넌트를 display none으로 숨기다보니 그 하위 컴포넌트 및 요소는 <code class=\"language-text\">React.memo</code>의 영향을 받아 렌더링이 다시 일어나지 않는 것 같았지만 <strong>(정확하지 않아 혹시 알게되면 추후 수정하도록 하겠습니다.)</strong>, 버튼을 눌렀을 때는 해당 메뉴 컴포넌트 (Flag에 따라 변경되는)의 하위요소가 모두 다시 렌더링 되는 것을 확인할 수 있다. 이때 작성한 코드는 아래와 같다.</p>\n<ul>\n<li>\n<p>Filter Menu부분의 최상단 컴포넌트 [FilterDetail]</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/*\n...\n*/\nreturn (\n&lt;ThemeProvider theme={ buttonTheme }&gt;\n    &lt;Style.DetailWrapper filterFlag={ filterFlag }&gt; //filterFlag가 화살표 버튼의 Flag\n        &lt;Location \n            activeBtn={ activeBtn }\n            setFilterData={ setFilterData }\n        /&gt;\n        &lt;Keywords \n            activeBtn={ activeBtn }\n            setFilterData={ setFilterData }\n        /&gt;\n        &lt;Recommendation\n            activeBtn={ activeBtn }\n            setFilterData={ setFilterData }\n        /&gt;\n        &lt;Level \n            activeBtn={ activeBtn }\n            setFilterData={ setFilterData }\n        /&gt;\n/*\n...\n*/</code></pre></div>\n</li>\n<li>\n<p>하위컴포넌트 중 하나인 [Location] (모든 컴포넌트의 html 구조는 동일)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">return (\n&lt;Style.RecommendWrapper \n  activeBtn={ activeBtn } // activeBtn이 주제별 버튼의 Flag\n  className=&#39;dropdown__menus&#39;\n&gt;\n  { dropdownList }\n&lt;/Style.RecommendWrapper&gt;</code></pre></div>\n</li>\n<li>\n<p>Flag에 따라 변경되는 Style 부분</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">display: ${({ filterFlag }) =&gt; !filterFlag &amp;&amp; &#39;none&#39;};\ndisplay: ${({ activeBtn }) =&gt; activeBtn !== &#39;recommendation&#39; &amp;&amp; &#39;none&#39; };</code></pre></div>\n</li>\n</ul>\n<p>display none은 DOM Tree에 반영은 되지만 Render Tree에 반영되지 않는 특성이 있다. 이 때문에 당연히 개발자 도구에서 Filter Menu 컴포넌트들이 추가된 것을 확인할 수 있다. (Location, Keywords, Recommendation, Level)</p>\n<p><img src=\"https://user-images.githubusercontent.com/37759759/69441170-8750f100-0d8d-11ea-8319-d55d2c13c646.JPG\" alt=\"displayNone\"></p>\n<p>React Dev Tools <code class=\"language-text\">Components</code> Tab에서도 Rendering이 이미 되어 있는 것을 확인할 수 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/37759759/69441362-edd60f00-0d8d-11ea-8da4-54874669a01f.JPG\" alt=\"displayNone2\"></p>\n<p>당연하겠지만, DOM TREE에 있는 것은 이미 자원을 소비하고 있는 것이라고 생각했다. 또한 불필요하게 하위 요소를 포함한 모든 컴포넌트의 Re-rendering이 빈번하게 일어난다면, 이 또한 최적화가 필요할 것이라고 생각했다. 그렇게 조건부 렌더링으로 변경하게 되었다.</p>\n<h2 id=\"conditional-rendering-조건부-렌더링\"><a href=\"#conditional-rendering-%EC%A1%B0%EA%B1%B4%EB%B6%80-%EB%A0%8C%EB%8D%94%EB%A7%81\" aria-label=\"conditional rendering 조건부 렌더링 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conditional Rendering (조건부 렌더링)</h2>\n<p><a href=\"https://ko.reactjs.org/docs/conditional-rendering.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">조건부 렌더링</a>은 쉽게 말해서 <code class=\"language-text\">return flag &amp;&amp; &lt;Component /&gt;</code>와 같은 방법으로 flag가 true일 때 컴포넌트를 Rendering 하는 방법이다. 조건부 렌더링을 적용하기 전에 예상했던 것은 조건부 렌더링은 조건에 따라 컴포넌트 또는 요소를 Rendering 해주기 때문에 <code class=\"language-text\">display: none</code>의 방식과 같이 DOM Tree에 추가되는 현상은 없을 것으로 판단했다. 그렇게 적용을 하고 난 결과는 내 예상과 같았다.</p>\n<p>아래의 사진에서 각 Menu 컴포넌트의 하위요소는 다시 Re-rendering이 발생하지 않는 것을 볼 수 있다.\n<img src=\"https://user-images.githubusercontent.com/37759759/69442376-d861e480-0d8f-11ea-80fa-711726e1d598.gif\" alt=\"2019-11-22-23-17-41\"></p>\n<p>각 Menu 컴포넌트는 당연히 새롭게 렌더링이 되는 것이기 때문에 Re-rendering이 되는 것이 맞지만 내부 요소들은 React.memo를 통해 memoized된 상태이기 때문에 Re-rendering이 발생하지 않는 다고 생각한다.</p>\n<p>다음은 DOM의 구조를 확인할 수 있다.\n<img src=\"https://user-images.githubusercontent.com/37759759/69442733-6d64dd80-0d90-11ea-9d55-bd6e68939367.JPG\" alt=\"Conditional1\"></p>\n<p><code class=\"language-text\">display: none</code>의 방식에서 4개의 컴포넌트가 모두 렌더링된 것과는 다르게 Menu 컴포넌트 하나와 버튼 UI만 Rendering된 것을 확인할 수 있다.</p>\n<p>하지만 조금 예상 밖이었던 것은, 아래 사진과 같이 React Dev Tools의 <code class=\"language-text\">Components</code> Tab에서는 4개의 컴포넌트를 확인할 수 있는 점이였다..\n<img src=\"https://user-images.githubusercontent.com/37759759/69443153-33480b80-0d91-11ea-829c-32e4c091711a.png\" alt=\"2019-11-22-23-20-46\"></p>\n<p>리팩토링을 위해 코드를 점검해보니, <code class=\"language-text\">display: none</code> 방식의 위와 같은 형태처럼 flag를 넘겨주고 각 Menu 컴포넌트 내에서 조건부 렌더링을 걸어준 것이 문제라는 것을 발견했다.</p>\n<p>아래 그 문제의 코드를 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;Location \n    activeBtn={ activeBtn }\n    setFilterData={ setFilterData }\n/&gt;</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">return activeBtn === &#39;location&#39; &amp;&amp; (\n    &lt;div\n      className=&#39;dropdown__menus&#39;\n    &gt;\n      &lt;FilterMenu \n        menuTitle=&#39;도시명&#39;\n        onChange={ ({ target }) =&gt; setCity(target.value) }\n        optionValues={ cities }\n      /&gt;\n      &lt;FilterMenu \n        menuTitle=&#39;군/구&#39;\n        onChange={ ({ target }) =&gt; setGu_nm(target.value)}\n        optionValues={ locationDetail[city] }\n      /&gt;\n    &lt;/div&gt;\n  );</code></pre></div>\n<h2 id=\"해당-ui-최상단-컴포넌트에서-conditional-rendering-적용하기\"><a href=\"#%ED%95%B4%EB%8B%B9-ui-%EC%B5%9C%EC%83%81%EB%8B%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C-conditional-rendering-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"해당 ui 최상단 컴포넌트에서 conditional rendering 적용하기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해당 UI 최상단 컴포넌트에서 Conditional Rendering 적용하기</h2>\n<p>이 문제를 해결하기 위해서 Menu 컴포넌트들을 관리하는 최상단 컴포넌트 [FilterDetail] 컴포넌트에서 조건부 렌더링을 적용시키려고 시도했다. 결과는 예상과 같았다. 다른 부분은 모두 위의 설명과 같았고, 문제시 되었던 React Dev Tools <code class=\"language-text\">Components</code> Tab에서의 4개 컴포넌트가 렌더된 것은 명확하게 해결한 것을 확인할 수 있었다.</p>\n<p>먼저 코드는 아래와 같이 useMemo와 Switch 문을 활용해 작성했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const filterRenderer = useMemo(() =&gt; {\n    switch(activeBtn) { // 각 Menu 컴포넌트에 대한 Flag\n      case &#39;location&#39;:\n        return (\n          &lt;Location \n            setFilterData={ setFilterData }\n          /&gt;\n        );\n      case &#39;keywords&#39;:\n        return(\n          &lt;Keywords \n            setFilterData={ setFilterData }\n          /&gt;\n        );\n      case &#39;recommendation&#39;:\n        return (\n          &lt;Recommendation\n            setFilterData={ setFilterData }\n          /&gt;\n        );\n      case &#39;level&#39;:\n        return (\n          &lt;Level \n            setFilterData={ setFilterData }\n          /&gt;\n        );\n      default:\n        break;\n    }\n  }, [activeBtn]);</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> return filterFlag &amp;&amp; ( // 화살표 버튼에 대한 Flag\n    &lt;ThemeProvider theme={ buttonTheme }&gt;\n      &lt;Style.DetailWrapper&gt;\n        { filterRenderer }\n/*\n.\n.\n.\n*/</code></pre></div>\n<p>아래는 그 결과에 따른 Render 결과이다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/37759759/69444112-0694f380-0d93-11ea-8263-1ddb07df0b61.JPG\" alt=\"Conditional2\"></p>\n<p>위의 사진에서 보시다시피 Location 하나의 Component만 Rendering 되었다.</p>\n<p>하지만, React Dev Tools의 Profiler Tab을 확인했을 때는 <code class=\"language-text\">Context.consumer</code> 컴포넌트의 호출시간이 각 Menu 컴포넌트에서 Flag를 사용했을 때 보다 길게 나왔는데, 사실 Profiler의 사용법은 아직 거의 습득하지 못해서 추후 학습하며 수정이 필요하다면 수정해 나가도록 해야겠다.</p>\n<h2 id=\"rendering의-차이점을-확인해보면서\"><a href=\"#rendering%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%84-%ED%99%95%EC%9D%B8%ED%95%B4%EB%B3%B4%EB%A9%B4%EC%84%9C\" aria-label=\"rendering의 차이점을 확인해보면서 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Rendering의 차이점을 확인해보면서..</h2>\n<p>일단 컴포넌트를 호출해서 그 컴포넌트 안에서 조건부 렌더링으로 처리한 것이기 때문에 어쩌면 너무나도 당연한 문제였을 수도 있다. 하지만 경험이 없었던 터라 이런 부분에 대해 명확하게 머릿속에 새긴 기회가 되어 매우 좋았고, 정리하면서 조금은 미흡했던 개념을 잡을 수 있어 좋았다. 아직 프로젝트에 이런 Rendering이 최적화되지 못한 컴포넌트들이 많은데, Filter UI를 완성하고 나면 Refactoring의 시간을 갖는 것이 좋을 것 같다.</p>\n<hr>\n<blockquote>\n<p>공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.</p>\n</blockquote>\n<hr>","fields":{"slug":"/posts/conditional-rendering-vs-diplay-none","tagSlugs":["/tag/conditional-redering/","/tag/react/","/tag/javascript/","/tag/display-none/"]},"frontmatter":{"date":"2019-11-22T19:21:09.000Z","description":"프로젝트를 진행하면서 조건부 렌더링과 display none을 사용한 렌더링의 차이점을 정리하고자한다. 최적화를 위해 차이점을 비교하며 더 나은 렌더링 방식을 선택하려한다.","tags":["Conditional Redering","React","Javascript","display none"],"title":"조건부 렌더링 vs display none","socialImage":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/conditional-rendering-vs-diplay-none"}}}