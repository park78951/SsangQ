{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/custom-react-router","result":{"data":{"markdownRemark":{"id":"1dec4332-f69d-5ecd-836d-40c6bbba78f8","html":"<p>React Router를 학습하기 위해 React Router를 Customizing한 블로그를 뒤져가며 나도 같이 만들어보며 원리를 이해하고자 학습하고 이렇게 정리하고자 한다.</p>\n<h2 id=\"react-router\"><a href=\"#react-router\" aria-label=\"react router permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React Router</h2>\n<p>React Router Dom Library를 사용하면서 React Router가 어떤식으로 동작하는지 궁금했다. 함께 공부하는 분이 이전에 학습하고 만들어봤던 custom router를 참고해서 일단 따라 만들어보며 이해하려고 노력했다. 사실 React Router와 완전히 같지는 않지만 사용이 상당히 비슷하기 때문에 몇몇 Api를 제외하고는 내부 동작 또한 비슷할 것으로 생각된다. 차근 차근 정리해보려한다.</p>\n<h3 id=\"필요한-libraries\"><a href=\"#%ED%95%84%EC%9A%94%ED%95%9C-libraries\" aria-label=\"필요한 libraries permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>필요한 libraries</h3>\n<p>먼저 Custom Router를 만들기 위해서는 <a href=\"https://www.npmjs.com/package/history\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">history</a>, <a href=\"https://www.npmjs.com/package/querystringify\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">querystringify</a> libraries가 필요하다. <strong>history</strong> library는 브라우저의 history 즉, 페이지 이동의 정보를 관리하는 library이고, <strong>querystringify</strong>는 말 그대로 URL의 query string을 파싱해주는 작업을 도와준다.</p>\n<h3 id=\"router를-만들기에-앞서\"><a href=\"#router%EB%A5%BC-%EB%A7%8C%EB%93%A4%EA%B8%B0%EC%97%90-%EC%95%9E%EC%84%9C\" aria-label=\"router를 만들기에 앞서 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Router를 만들기에 앞서</h3>\n<p>일단 현재 경로와 같은 Routing 정보는 전역에서 접근이 가능해야 Link와 Route가 제 기능을 다 할 수 있을 것이다. 이를 위해 여기서는 Context Api를 사용해 routing 정보를 전역에서 접근할 수 있게 한다.</p>\n<h3 id=\"custom-router\"><a href=\"#custom-router\" aria-label=\"custom router permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Custom Router</h3>\n<h4 id=\"1-location-정보-분석을-도와주는-함수\"><a href=\"#1-location-%EC%A0%95%EB%B3%B4-%EB%B6%84%EC%84%9D%EC%9D%84-%EB%8F%84%EC%99%80%EC%A3%BC%EB%8A%94-%ED%95%A8%EC%88%98\" aria-label=\"1 location 정보 분석을 도와주는 함수 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Location 정보 분석을 도와주는 함수</h4>\n<p>현재 브라우저 Location (URL 내부의) 정보를 쪼개는 util 함수를 먼저 만든다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import qs from &#39;querystringify&#39;;\n\nexport function locationToRoute(location) {\n  // location comes from the history package\n  return {\n    path: location.pathname,\n    hash: location.hash,\n    query: qs.parse(location.search),\n  };\n}</code></pre></div>\n<p>인자로 location 정보를 받으면, location의 프로퍼티인 pathname, hash, search 정보를 추후 사용하기 쉽게 객체로 저장하도록 한다.</p>\n<h4 id=\"2-router-context\"><a href=\"#2-router-context\" aria-label=\"2 router context permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Router Context</h4>\n<p>이제 Router 정보를 전역에서 접근할 수 있도록 Context Api를 사용해 만든다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from &quot;react&quot;;\nimport { createBrowserHistory } from &quot;history&quot;;\nimport { locationToRoute } from &quot;./utils&quot;;\n\nexport const history = createBrowserHistory();\n\nexport const RouterContext = React.createContext({\n  route: locationToRoute(history.location),\n});</code></pre></div>\n<p>먼저 history library에서 createBrowserHistory Api를 사용해 새로운 browser history를 만든다. 그리고 새로운 Context를 만드는데, <strong>route</strong> 프로퍼티에 현재 location을 저장하는 객체를 Context 초기값으로 설정해준다. <strong>route</strong> 프로퍼티의 값은 util 함수로 만들었던 <code class=\"language-text\">locationToRoute</code>에 history.location을 인자로 넣어 결과 값을 저장한다.\n이제 useContext로 context를 불러 현재 path, hash, query 값에 접근할 수 있다.</p>\n<h4 id=\"3-route와-link-component\"><a href=\"#3-route%EC%99%80-link-component\" aria-label=\"3 route와 link component permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Route와 Link Component</h4>\n<p>React Route의 주 기능을 담당하는 <code class=\"language-text\">Route</code>와 <code class=\"language-text\">Link</code> 컴포넌트를 만들 차례다. </p>\n<p><code class=\"language-text\">Route</code> 컴포넌트는 url에 제공되는 path가 일치할 경우 컴포넌트를 띄우는 작업을 수행한다.\n<code class=\"language-text\">Link</code> 컴포넌트는 전체 페이지를 Re-loading하지 않고 <code class=\"language-text\">history</code> api를 통해 URL의 path를 바꿔주는 작업을 수행한다.</p>\n<p>이렇게 Link가 전체 페이지의 Re-loading 없이 path를 바꿔주고, Route 컴포넌트에서는 path에 따라 해당하는 컴포넌트만 render해주는 작업으로 이뤄진다.\n그러면 useContext를 사용해 위에서 만든 Context의 데이터를 사용해 <code class=\"language-text\">Route</code>와 <code class=\"language-text\">Link</code> 컴포넌트를 만들어보자.</p>\n<h5 id=\"router\"><a href=\"#router\" aria-label=\"router permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Router</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from &quot;react&quot;;\nimport { RouterContext } from &quot;./context&quot;;\n\nexport function Route({ path, children }) {\n  // Extract route from RouterContext\n  const { route } = React.useContext(RouterContext);\n\n  // Return null if the supplied path doesn&#39;t match the current route path\n  if (route.path !== path) {\n    return null;\n  }\n\n  return children;\n}</code></pre></div>\n<p>Router 컴포넌트는 2개의 props를 받는데, <code class=\"language-text\">path와</code> <code class=\"language-text\">children</code>이다. <code class=\"language-text\">children</code>은 <code class=\"language-text\">Route</code>의 자식요소로 전달된 컴포넌트를 그대로 가져와서 렌더링 하기위함이고, <code class=\"language-text\">path</code>는 위에서 보다시피 Context로 가져온 route 정보에서 현재 path와 비교 후 인자로 들어온 path와 Context에 있는 path가 일치하지 않으면 새로운 뷰 (children이 갖고 있는)를 출력해준다.</p>\n<h5 id=\"link\"><a href=\"#link\" aria-label=\"link permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Link</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from &quot;react&quot;;\nimport { RouterContext, history } from &quot;./context&quot;;\n\nexport function Link(props) {\n  const { to, onClick, children } = props;\n\n  // Extract route from RouterContext\n  const { route } = React.useContext(RouterContext);\n  const handleClick = (e) =&gt; {\n    e.preventDefault();\n\n    // Dont&#39; navigate if current path\n    if (route.path === to) {\n      return;\n    }\n\n    // Trigger onClick prop manually\n    if (onClick) {\n      onClick(e);\n    }\n\n    // Use history API to navigate page\n    history.push(to)\n  };\n\n  return (\n    &lt;a {...props} onClick={handleClick}&gt;\n      {children}\n    &lt;/a&gt;\n  );\n}</code></pre></div>\n<p>Link는 <code class=\"language-text\">to</code>, <code class=\"language-text\">onClick</code>, <code class=\"language-text\">children</code> props를 받는다. <code class=\"language-text\">to</code>는 URL을 변경할 path를 의미한다. 현재 Link 컴포넌트를 클릭하면 Context에 저장된 현재 <code class=\"language-text\">path(route.path)</code>와 비교해서 같지 않으면 인자로 받은 to를 <code class=\"language-text\">history.push(to)</code>와 같은 방법으로 history에 추가해 줌으로써 현재 path를 바꿔 Route에 알려주는 역할을 한다. 인자로 받은 onClick은 단순히 onClick 함수가 있다면 해당 event 객체를 전달하기 위함이고, children은 변경 없이 Link 기능만 갖도록 하여 출력하도록 return한다.</p>\n<p>여기서 중요한 것은 <code class=\"language-text\">a</code> tag의 사용이라고 생각한다. 일반적으로 서버사이드 렌더링에서는 HTML에서 <code class=\"language-text\">a</code> Tag를 사용해 페이지 전환을 하는데, SPA에서도 마찬가지로 <code class=\"language-text\">a</code> Tag를 사용해 이 작업을 진행하고 있었다. 또한 page 전체 Re-loading을 막기 위해 <code class=\"language-text\">e.preventDefault()</code>를 사용했다는 점까지, 생각보다 상당히 간단하게 구현이 가능하구나 라는 느낌을 받았다.</p>\n<h3 id=\"4-router-component\"><a href=\"#4-router-component\" aria-label=\"4 router component permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Router Component</h3>\n<p>이렇게 각 컴포넌트에서 Context를 데이터를 사용하고 변경할 수 있으려면 <code class=\"language-text\">Provider</code> 컴포넌트가 필요하다. 이와 함께 추가적인 기능을 수행하는 <code class=\"language-text\">Router</code> 컴포넌트를 알아보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from &quot;react&quot;;\nimport { locationToRoute } from &quot;./utils&quot;;\nimport { history, RouterContext } from &quot;./context&quot;;\nimport { Route } from &quot;./route&quot;;\nimport { Link } from &quot;./link&quot;;\n\nclass Router extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // Convert our routes into an array for easy 404 checking\n    this.routes = Object.keys(props.routes).map((key) =&gt; props.routes[key].path);\n\n    // Listen for path changes from the history API\n    this.unlisten = history.listen(this.handleRouteChange);\n\n    // Define the initial RouterContext value\n    this.state = {\n      route: locationToRoute(history.location),\n    };\n  }\n\n  componentWillUnmount() {\n    // Stop listening for changes if the Router component unmounts\n    this.unlisten();\n  }\n  \n  handleRouteChange = (location) =&gt; {\n    const route = locationToRoute(location);\n    this.setState({ route: route });\n  }\n\n  render() {\n    // Define our variables\n    const { children, NotFound } = this.props;\n    const { route } = this.state;\n\n    // Create our RouterContext value\n    const routerContextValue = { route };\n\n    // Check if 404 if no route matched\n    const is404 = this.routes.indexOf(route.path) === -1;\n\n    return (\n      &lt;RouterContext.Provider value={routerContextValue}&gt;\n        {is404 ? &lt;NotFound/&gt; : children}\n      &lt;/RouterContext.Provider&gt;\n    );\n  }\n}\n\nexport { history, RouterContext, Router, Route, Link }</code></pre></div>\n<p>Router는 먼저 2개의 props를 받는데, <code class=\"language-text\">routes list</code>와 404 에러처리에 대한 <code class=\"language-text\">NotFound</code> 컴포넌트이다. 이 두 props는 <code class=\"language-text\">routes list</code>로 등록할 path를 모두 확인해 해당 경로가 없을 경우 바로 <code class=\"language-text\">NotFound</code> 컴포넌트를 출력해주기 위함이다.</p>\n<p>또한 RouterContext를 통해 route 값을 각 컴포넌트에 전달하는 역할도 하고있고, <code class=\"language-text\">history.listen</code>을 통해 현재 history의 변경을 route값으로 저장하고 있다. 마지막으로는 export로 모든 컴포넌트를 한번에 export하는 모습을 볼 수 있다.</p>\n<p><code class=\"language-text\">react-router-dom</code>을 열어보니 Context Propvider 역할을 Switch에서 하고 있으며, <code class=\"language-text\">history</code>를 BrowserRouter에서 생성해 Router 컴포넌트로 전달하고 있었다.</p>\n<p>아래는 이 Costom Router를 사용한 코드이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export const routes = {\n  home: {\n    path: &quot;/&quot;,\n  },\n  about: {\n    path: &quot;/about&quot;\n  },\n};</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from &quot;react&quot;;\nimport ReactDOM from &quot;react-dom&quot;;\nimport {Router, Link, Route, history} from &quot;./router&quot;;\nimport {routes} from &quot;./routes&quot;;\n\nfunction NotFound() {\n  return (\n    &lt;div&gt;\n      &lt;p&gt;404 - Not Found&lt;/p&gt;\n      &lt;Link to={routes.home.path}&gt;Back to home&lt;/Link&gt;\n    &lt;/div&gt;\n  )\n}\n\nfunction App() {\n  return (\n    &lt;Router routes={routes} NotFound={NotFound}&gt;\n      &lt;Route path={routes.home.path}&gt;\n        &lt;p&gt;Home&lt;/p&gt;\n        &lt;Link to={routes.about.path}&gt;Go to about&lt;/Link&gt;\n        &lt;Link to=&quot;/unknown&quot;&gt;Go to unknown route&lt;/Link&gt;\n        &lt;div className=&quot;link&quot; onClick={() =&gt; history.push(routes.about.path)}&gt;\n          Programmatically go to about\n        &lt;/div&gt;\n      &lt;/Route&gt;\n      &lt;Route path={routes.about.path}&gt;\n        &lt;p&gt;About&lt;/p&gt;\n        &lt;Link to={routes.home.path}&gt;Go to home&lt;/Link&gt;\n      &lt;/Route&gt;\n    &lt;/Router&gt;\n  );\n}\n\nconst rootElement = document.getElementById(&quot;root&quot;);\nReactDOM.render(&lt;App /&gt;, rootElement);</code></pre></div>\n<hr>\n<blockquote>\n<p>공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.</p>\n</blockquote>\n<hr>","fields":{"slug":"/posts/custom-react-router","tagSlugs":["/tag/router/","/tag/react/","/tag/react-router-dom/","/tag/customized-router/"]},"frontmatter":{"date":"2019-10-22T11:38:22.000Z","description":"React Router를 학습하기 위해 React Router를 Customizing한 블로그를 뒤져가며 나도 같이 만들어보며 원리를 이해하고자 학습하고 이렇게 정리하고자 한다.","tags":["Router","React","react-router-dom","customized router"],"title":"Router Api 뜯어보기","socialImage":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/custom-react-router"}}}