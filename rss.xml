<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Develop To be a Developer]]></title><description><![CDATA[Like Development
Like Creation]]></description><link>https://ssangq.netlify.com/</link><generator>GatsbyJS</generator><lastBuildDate>Mon, 16 Dec 2019 04:39:19 GMT</lastBuildDate><item><title><![CDATA[Webpack 설정과 Boiler Plate]]></title><description><![CDATA[계속해서 React를 쓰던 요즘, CRA가 아닌 Webpack 설정이 된 boiler plate를 만들어 놓고 계속 사용하면서 차츰 희미해져가는 Wepack의 설정들을 다시 되짚어보고자 한다.]]></description><link>https://ssangq.netlify.com//posts/webpack</link><guid isPermaLink="false">https://ssangq.netlify.com//posts/webpack</guid><pubDate>Tue, 10 Dec 2019 21:19:33 GMT</pubDate><content:encoded>&lt;h2 id=&quot;웹팩으로&quot;&gt;&lt;a href=&quot;#%EC%9B%B9%ED%8C%A9%EC%9C%BC%EB%A1%9C&quot; aria-label=&quot;웹팩으로 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;웹팩으로&lt;/h2&gt;
&lt;p&gt;처음 React를 사용할 때 CRA를 사용하기보다 Webpack을 공부해서 React 설정을 직접하는 것을 배우는 것이 좋다고하여 직접 설정해보기 시작했다. 그 때는 너무 복잡했던 Webpack에 익숙해지기가 너무 힘들었는데, 계속 options이나 plugin 등을 추가하고 에러를 고쳐보면서 Webpack을 분석하는 눈이 생겼고 Webpack의 기능과 추가한 플러그인들의 하는일이 무엇인지 알고 쓸 수 있어 너무 만족한다. 계속해서 CRA만 사용했다면 이러한 발전은 없었을 것이다.&lt;/p&gt;
&lt;p&gt;Webpack은 사용하면 사용할수록 다양한 효율적인 기능이 있고 아직도 사용해보지는 못했지만 알게되는 기능들이 개발의 효율을 높여준다고 느꼈다. 하지만 webpack을 사용하면서 의식적으로 생각해야할 점은 &lt;strong&gt;&lt;em&gt;필요에 의한 사용&lt;/em&gt;&lt;/strong&gt; 이라고 생각한다. 내가 당장 필요도 없는데 남이 쓰는 좋은 설정이라고 해서 무작정 추가하는 식의 접근 좋지 않다는 점을 생각하고 써야할 것이다. 이러한 이유때문에 좀 더 이론적인 부분도 다시 한 번 정리하고 싶었고, 사용 목적이나 자주 사용하는 부분의 특징들도 함께 정리하려고한다.&lt;/p&gt;
&lt;h2 id=&quot;웹팩이란&quot;&gt;&lt;a href=&quot;#%EC%9B%B9%ED%8C%A9%EC%9D%B4%EB%9E%80&quot; aria-label=&quot;웹팩이란 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;웹팩이란?&lt;/h2&gt;
&lt;p&gt;웹팩이란 &lt;strong&gt;모듈 번들러(Module Bundler)&lt;/strong&gt;이다. 간단하게 말하면 웹 어플리케이션을 구성하는 자원들을 하나로 합쳐 새로운 결과물로 만드는 도구이다. 웹팩을 사용하면 일반적으로 bundle.js라는 하나의 javascirpt 파일을 생성하는데, 이 파일에는 내가 작성한 코드, 라이브러리, CSS와 HTML 등의 정보를 모두 하나로 함축해놨다고 보면 되겠다. (사실 너무 복잡하고 암호화같은 코드라서 정확하게 하나씩 찾아보진 못했다…)&lt;/p&gt;
&lt;p&gt;다시말해서, 웹팩에서 말하는 &lt;strong&gt;모듈&lt;/strong&gt;의 개념은 위에서 언급한 바와 같이 웹 어플리케이션을 구성하는 모든 자원을 의미한다고 한다. (HTML, CSS, Javascript, Imgaes, Font 등) 그리고 내부적으로 이러한 모듈들의 의존성 그래프를 형성해 하나 이상의 번들 파일을 생성한다고 한다. (일반적으로 번들 파일 하나지만, 최적화를 위해 번들 파일을 나눠서 관리하기도 한다.)&lt;/p&gt;
&lt;h2 id=&quot;웹팩의-필요성&quot;&gt;&lt;a href=&quot;#%EC%9B%B9%ED%8C%A9%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1&quot; aria-label=&quot;웹팩의 필요성 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;웹팩의 필요성?&lt;/h2&gt;
&lt;p&gt;웹팩이 나온 배경에는 다음과 같은 이유가 있다고 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파일 단위의 자바스크립트 모듈 관리의 필요성&lt;/li&gt;
&lt;li&gt;웹 개발 작업 자동화 도구로서&lt;/li&gt;
&lt;li&gt;웹 어플리케이션의 빠른 로딩 속도와 높은 성능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;파일단위의-자바스크립트-모듈-관리의-필요성&quot;&gt;&lt;a href=&quot;#%ED%8C%8C%EC%9D%BC%EB%8B%A8%EC%9C%84%EC%9D%98-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AA%A8%EB%93%88-%EA%B4%80%EB%A6%AC%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1&quot; aria-label=&quot;파일단위의 자바스크립트 모듈 관리의 필요성 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;파일단위의 자바스크립트 모듈 관리의 필요성&lt;/h3&gt;
&lt;p&gt;이러한 모듈관리는 전역변수를 관리하는데 큰 이점이 있다고 한다. HTML에서 각 js 파일을 모두 로드하는 것은 변수 중복문제에 부딪혀 코드가 많아질 수록 굉장히 힘들 수가 있다.&lt;/p&gt;
&lt;p&gt;하지만, HTML파일에서도 script tag의 &lt;code class=&quot;language-text&quot;&gt;type=&amp;#39;module&lt;/code&gt;을 통해 파일단위 js파일을 관리할 수도 있다. 그러나 webpack을 통한 module bundling은 babel 등의 transpiling 도구를 함께 사용할 수 있다는 이점이 있고 성능적 측면에서도 webpack으로 번들링을 한 것이 프로젝트 규모가 커질수록 더 큰 이점이 있다고 한다. &lt;a href=&quot;https://docs.google.com/document/d/1ovo4PurT_1K4WFwN2MYmmgbLcr7v6DRQN67ESVA-wq0/pub&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;모듈환경 병목현상 Report&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;웹-개발-작업-자동화-도구로서&quot;&gt;&lt;a href=&quot;#%EC%9B%B9-%EA%B0%9C%EB%B0%9C-%EC%9E%91%EC%97%85-%EC%9E%90%EB%8F%99%ED%99%94-%EB%8F%84%EA%B5%AC%EB%A1%9C%EC%84%9C&quot; aria-label=&quot;웹 개발 작업 자동화 도구로서 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;웹 개발 작업 자동화 도구로서&lt;/h3&gt;
&lt;p&gt;내가 지금 사용하고 있는 &lt;code class=&quot;language-text&quot;&gt;react-hot-loader&lt;/code&gt;와 같은 자동 페이지 reloader tool과 다양한 압축 기능은 웹팩의 또다른 장점이라고 한다.&lt;/p&gt;
&lt;h3 id=&quot;웹-어플리케이션의-빠른-로딩-속도와-높은-성능&quot;&gt;&lt;a href=&quot;#%EC%9B%B9-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%98-%EB%B9%A0%EB%A5%B8-%EB%A1%9C%EB%94%A9-%EC%86%8D%EB%8F%84%EC%99%80-%EB%86%92%EC%9D%80-%EC%84%B1%EB%8A%A5&quot; aria-label=&quot;웹 어플리케이션의 빠른 로딩 속도와 높은 성능 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;웹 어플리케이션의 빠른 로딩 속도와 높은 성능&lt;/h3&gt;
&lt;p&gt;Lazy Loading과 Code splitting, Tree Shaking과 같은 최적화 작업을 Webpack에서 지원하기 때문에 특히, SPA를 사용한다면 큰 이득이 될 수 있다.&lt;/p&gt;
&lt;p&gt;Lazy Loading은 말 그대로 어떤 자원을 필요할 때 서버로부터 받아오는 것이고, code splitting은 코드를 chunk 단위로 나눠서 관리하는 것이다. Tree Shaking은 번들링 과정에서 사용하지 않는 코드를 제거하는 최적화 과정이라고 할 수 있겠다.&lt;/p&gt;
&lt;h2 id=&quot;나의-react-boiler-plate의-webpack-설정&quot;&gt;&lt;a href=&quot;#%EB%82%98%EC%9D%98-react-boiler-plate%EC%9D%98-webpack-%EC%84%A4%EC%A0%95&quot; aria-label=&quot;나의 react boiler plate의 webpack 설정 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;나의 React Boiler Plate의 Webpack 설정&lt;/h2&gt;
&lt;p&gt;한창 CRA가 너무 편한데 왜 Webpack을 힘들게 설정해서 사용해야하는가? 라는 의문을 가졌던 적이 있을 무렵, 다양한 외국 블로그에서 CRA를 왜 사용안하는지 모르겠다는 논쟁을 접하기도 했다.&lt;/p&gt;
&lt;p&gt;하지만, 지금도 CRA는 최고의 Boiler Plate라고 생각한다. 초보자가 React를 처음 시작할 때 여러가지 설정들을 러닝커브 없이 React를 시작할 수 있으며, 중급 이상의 개발자가 사용할 때도 많은 수고를 덜어준다고 생각한다. 또한, 계속해서 업데이트를 해 호환되지 않던 문제도 많이 개선되었다.&lt;/p&gt;
&lt;p&gt;그래도 나는 Webpack을 직접 설정하고 싶다. 조금은 개발자 스러워(?)졌다고 해야할지는 모르겠으나, 지금은 내가 사용하는 것들이 최소한 작업을 위해 존재하는지를 알아야겠다는 기준이 생겼다.&lt;/p&gt;
&lt;p&gt;앞으로도 계속 업데이트하면서 React 개발에 사용할 나의 Boiler Plate 설정을 정리해보려고 한다.&lt;/p&gt;
&lt;h4 id=&quot;webpackconfigjs&quot;&gt;&lt;a href=&quot;#webpackconfigjs&quot; aria-label=&quot;webpackconfigjs permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;webpack.config.js&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;module&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;exports &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  mode&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;development&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  entry&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;react-hot-loader/patch&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;./src/index.js&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  output&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    path&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; path&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;__dirname&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;build&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    filename&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;bundle.js&apos;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  module&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    rules&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        test&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token regex&quot;&gt;/\.(js)$/&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        exclude&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token regex&quot;&gt;/node_modules/&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        use&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;babel-loader&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  resolve&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    alias&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&apos;react-dom&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;@hot-loader/react-dom&apos;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  plugins&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HtmlWebPackPlugin&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      template&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;public/index.html&apos;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CleanWebpackPlugin&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;build&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;mode&quot;&gt;&lt;a href=&quot;#mode&quot; aria-label=&quot;mode permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;mode&lt;/h3&gt;
&lt;p&gt;기본 mode 설정은 &lt;code class=&quot;language-text&quot;&gt;development&lt;/code&gt;로 작성했다. &lt;/p&gt;
&lt;p&gt;웹팩의 실행모드를 실행모드 설정 코드로 빌드과정에서 CLI나 &lt;code class=&quot;language-text&quot;&gt;process.env.NODE_ENV&lt;/code&gt;와 같은 추가 설정을 통해 모드를 지정할 수 있다. 추후 변경하기 전에 일단 작업에 사용할 목적으로 development 모드로 설정했다.&lt;/p&gt;
&lt;p&gt;실무에서는 dev.config나 production.config와 같이 개발 모드와 배포 모드를 따로 작성하기도 한다고 한다.&lt;/p&gt;
&lt;h3 id=&quot;entry&quot;&gt;&lt;a href=&quot;#entry&quot; aria-label=&quot;entry permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;entry&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;entry&lt;/code&gt;설정은 &lt;code class=&quot;language-text&quot;&gt;react-hot-loader&lt;/code&gt;와 module의 최상단 파일을 배열을 사용해 작성했다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;entry&lt;/code&gt; 설정은 기본적으로 Root 파일, 즉 module의 최상단 js파일을 의미한다. 기본적으로는 어플리케이션을 동작시킬 수 있는 코드가 있는 파일을 명시해야한다.&lt;/p&gt;
&lt;p&gt;일반적으로 string과 array, object로 표현할 수 있는데, string으로는 단순한 진입점을 표현하고, 배열은 나의 boiler plate와 같은 react-hot-loader를 사용할 때 함께 사용하고, 객체는 진입점을 여러개 설정할 때 사용한다고 한다. (배열 사용의 경우가 약간 아리송 하지만 일반적으로 서로 의존성 없는 파일들을 연결하고 싶을 때 사용한다고 한다.)&lt;/p&gt;
&lt;h3 id=&quot;output&quot;&gt;&lt;a href=&quot;#output&quot; aria-label=&quot;output permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;output&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;output&lt;/code&gt;은 bundle작업이 이뤄진 파일의 경로를 나타낸다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;path&lt;/code&gt;는 말 그대로 경로를, filename은 파일의 이름을 나타낸다. 이후 build 과정을 거치면 경로에 해당하는 폴더가 생성되고 안에 webpack 작업물들이 생성된다. 일반적으로 폴더명은 dist를 많이 사용하지만, build가 나에겐 더욱 직관적이라고 생각되어 build를 사용하고 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;filename&lt;/code&gt;은 일반적으로 bundle.js를 많이 사용한다. 나 역시 그 이름을 사용하고 있다. &lt;code class=&quot;language-text&quot;&gt;filename&lt;/code&gt;은 &lt;code class=&quot;language-text&quot;&gt;[name].bundle.js&lt;/code&gt;과 같이 entry 속성을 포함하는 이름, &lt;code class=&quot;language-text&quot;&gt;[id].bundle.js&lt;/code&gt;와 같은 웹팩 내부의 모듈 ID를 사용하는 방식도 있으며, code splitting이나 lazy loading으로 인해 번들 파일이 나눠지는 경우에는 &lt;code class=&quot;language-text&quot;&gt;[hash].bundle.js&lt;/code&gt;와 같은 방식의 이름을 많이 사용한다.&lt;/p&gt;
&lt;h3 id=&quot;module&quot;&gt;&lt;a href=&quot;#module&quot; aria-label=&quot;module permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;module&lt;/h3&gt;
&lt;p&gt;module 속성은 loader를 의미한다. boiler plate로는 babel-loader 하나만 사용하고 있다.&lt;/p&gt;
&lt;p&gt;다른 옵션을 설정할 수 있지만, 일반적으로 사용하는 경우 위와같이 rules 속성의 배열에 사용할 loader를 적는다. &lt;code class=&quot;language-text&quot;&gt;test&lt;/code&gt;속성은 loader를 적용할 패턴이나 파일을 의미하고, &lt;code class=&quot;language-text&quot;&gt;exclude&lt;/code&gt;는 제외할 항목 또는 파일, &lt;code class=&quot;language-text&quot;&gt;use&lt;/code&gt;는 사용할 loader를 말한다. &lt;code class=&quot;language-text&quot;&gt;use&lt;/code&gt;가 배열로 이뤄진 것을 보면 알 수 있듯 다수의 로더를 넣을 수 있고, string 형태로도 작성할 수 있다. 일반적으로 loader의 적용 순서는 오른쪽에서 왼쪽으로, 아래에서 위로 적용되기 때문에 예를 들어 sass를 사용한다면, &lt;code class=&quot;language-text&quot;&gt;sass-loader&lt;/code&gt;를 &lt;code class=&quot;language-text&quot;&gt;css-loader&lt;/code&gt;보다 오른쪽 또는 밑에 적어야한다.&lt;/p&gt;
&lt;p&gt;&amp;#x3C;예시&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;module&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  rules&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      test&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token regex&quot;&gt;/\.scss$/&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      use&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;css-loader&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;sass-loader&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;아래와 같은 옵션을 포함한 다수의 객체를 가진 배열 형태로도 use를 작성할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;module&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  rules&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      test&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token regex&quot;&gt;/\.css$/&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      use&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; loader&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;style-loader&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          loader&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;css-loader&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
          options&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; modules&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; loader&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;sass-loader&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;resolve&quot;&gt;&lt;a href=&quot;#resolve&quot; aria-label=&quot;resolve permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;resolve&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;resolve&lt;/code&gt;는 module을 어떻게 처리할지에 대한 내용이 담겨있다고 한다. 굉장히 추상적인 만큼 다양한 설정이 들어갈 수 있다고 생각하는데, 일단 나의 boiler plate 설정은 &lt;code class=&quot;language-text&quot;&gt;react-dom&lt;/code&gt;을 &lt;code class=&quot;language-text&quot;&gt;react-hot-loader&lt;/code&gt;에서 제공하는 라이브러리로 실행시키겠다는 의미라고 보면 될 것 같다. react-hot-loader가 react v16.6+에서는 아직 완전히 호환되지 않아 이를 사용하는 것으로 알고있다.&lt;/p&gt;
&lt;p&gt;위의 설명과 상통하지만, 더욱 쉽게 설명하자면 resolve의 alias 속성을 통해 아래와 같이 작성하여 마치 node_modules 파일을 불러오듯 해당 경로의 파일들을 불러올 수 있게 해준다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;module&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;exports &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//...&lt;/span&gt;
  resolve&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    alias&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      Utilities&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; path&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;__dirname&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;src/utilities/&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      Templates&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; path&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;__dirname&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;src/templates/&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// previous&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Utility &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;../../utilities/utility&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// with alias&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Utility &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Utilities/utility&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 편해졌다.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;아직 익숙하지 않아 사용하지는 않지만 이와 같은 방식도 추후 사용해보려고한다.&lt;/p&gt;
&lt;h3 id=&quot;plugins&quot;&gt;&lt;a href=&quot;#plugins&quot; aria-label=&quot;plugins permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;plugins&lt;/h3&gt;
&lt;p&gt;마지막으로 &lt;code class=&quot;language-text&quot;&gt;plugins&lt;/code&gt;는 웹팩이 추가적인 일을 하도록 기능을 제공하는 속성이다. 로더는 단순히 transpiling의 의미를 갖고 있지만, &lt;code class=&quot;language-text&quot;&gt;plugins&lt;/code&gt;는 결과물을 변형시킨다는 차이가 있다. &lt;/p&gt;
&lt;p&gt;나의 boiler plate에는 2가지 plugin을 추가했는데, 대부분 가장 기본적으로 사용하고 있다고 알고 있다. 그만큼 편하다.&lt;/p&gt;
&lt;p&gt;먼저, &lt;code class=&quot;language-text&quot;&gt;HtmlWebPackPlugin&lt;/code&gt;은 build 이후 자동으로 html 파일을 생성해주고 script 경로에까지 새로 bundle된 파일을 추가해주는 추가 작업을 수행하게 해준다. template 속성은 참조할 html 파일을 나타낸다.&lt;/p&gt;
&lt;p&gt;두번째로, &lt;code class=&quot;language-text&quot;&gt;CleanWebpackPlugin&lt;/code&gt;은 build할 때마다 build파일이 계속 추가되지 않도록 새로운 파일이 생성되기 전에 build 폴더 안의 파일들을 삭제해주는 작업을 수행한다.&lt;/p&gt;
&lt;h2 id=&quot;웹팩에-대한-생각&quot;&gt;&lt;a href=&quot;#%EC%9B%B9%ED%8C%A9%EC%97%90-%EB%8C%80%ED%95%9C-%EC%83%9D%EA%B0%81&quot; aria-label=&quot;웹팩에 대한 생각 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;웹팩에 대한 생각&lt;/h2&gt;
&lt;p&gt;웹팩이 ‘좋다’, ‘안좋다’라는 것을 말하기 보다는 웹팩 러닝커브에 대한 생각을 적고싶다. 항상 개발을 하면서 느끼지만, 웹팩이나 다른 라이브러리를 사용하는 것은 항상 익숙함의 문제라고 생각한다. 위와 같이 처음 익혀야하는 웹팩의 속성들이 너무 많고 복잡하기에 처음부터 겁을 먹는 경우가 많다고 생각한다. 또한 그 용도를 모두 파악해 100% 사용할 수는 없기 때문에 가장 기본적인 사용방법과 기능에 익숙해지고 이를 조금씩 추가하면서 익히는 것이 중요하다고 생각한다. 지금의 나도 계속 익숙해지기 위해 노력중이다.&lt;/p&gt;
&lt;p&gt;무엇보다 가장 중요하게 생각하는 것은 내가 사용하고 있는 속성이 무슨 일을 하는지 반드시 알아야 한다고 생각한다.&lt;/p&gt;
&lt;h2 id=&quot;도움받은-문서&quot;&gt;&lt;a href=&quot;#%EB%8F%84%EC%9B%80%EB%B0%9B%EC%9D%80-%EB%AC%B8%EC%84%9C&quot; aria-label=&quot;도움받은 문서 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;도움받은 문서&lt;/h2&gt;
&lt;p&gt;책: &lt;a href=&quot;https://joshua1988.github.io/webpack-guide/concepts/plugin.html#plugin&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;웹팩 핸드북&lt;/a&gt;
공식사이트: &lt;a href=&quot;https://webpack.js.org/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;웹팩&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</content:encoded></item><item><title><![CDATA[자료구조 - Tree]]></title><description><![CDATA[자료구조인 Tree 구조에 대해 공부한 것을 정리하려고 한다.]]></description><link>https://ssangq.netlify.com//posts/data-structure-tree</link><guid isPermaLink="false">https://ssangq.netlify.com//posts/data-structure-tree</guid><pubDate>Sun, 01 Dec 2019 19:30:13 GMT</pubDate><content:encoded>&lt;h2 id=&quot;til-tree&quot;&gt;&lt;a href=&quot;#til-tree&quot; aria-label=&quot;til tree permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;[TIL] Tree&lt;/h2&gt;
&lt;p&gt;트리 자료 구조는 자식 노드를 지닌 노드들로 구성된다. 일반적으로 DOM Tree에서 확인한 모양으로 가장 최상위에 &lt;code class=&quot;language-text&quot;&gt;root node&lt;/code&gt;를 갖고 있고 자식들이 아래로 마치 가지치기한 형태의 뻗어있다.
차근차근 다양한 Tree 구조에 대해 정리해보겠다.&lt;/p&gt;
&lt;h3 id=&quot;일반-tree-구조&quot;&gt;&lt;a href=&quot;#%EC%9D%BC%EB%B0%98-tree-%EA%B5%AC%EC%A1%B0&quot; aria-label=&quot;일반 tree 구조 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;일반 Tree 구조&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/37759759/69912849-a24cf080-1472-11ea-9cfa-4baca3882f2a.png&quot; alt=&quot;General-Tree-Structure&quot;&gt;&lt;/p&gt;
&lt;p&gt;일반적인 트리 구조는 많은 자식들을 갖고 있을 수 있다.
일반적으로 아래와 같이 간단하게 코드를 구현한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; value&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;children &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;TreeNode&lt;/code&gt;로 인스턴스를 만들면서 값을 넣어주고 자식들은 children에 넣어주면 된다.&lt;/p&gt;
&lt;h3 id=&quot;이진트리-binary-tree&quot;&gt;&lt;a href=&quot;#%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC-binary-tree&quot; aria-label=&quot;이진트리 binary tree permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이진트리 (Binary Tree)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cdn.geeksforgeeks.org/wp-content/uploads/binary-tree-to-DLL.png&quot; alt=&quot;Binary-Tree-Structure&quot;&gt;
출처: &lt;a href=&quot;https://www.cdn.geeksforgeeks.org/wp-content/uploads/binary-tree-to-DLL.png&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Geeks for Geeks&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이진트리는 자식 노드가 왼쪽, 오른쪽인 최대 두 개뿐인 트리구조이다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이진트리도 종류에 따라 &lt;strong&gt;완전이진트리&lt;/strong&gt;, &lt;strong&gt;포화이진트리&lt;/strong&gt;, &lt;strong&gt;균형이진트리&lt;/strong&gt;, &lt;strong&gt;편향이진트리&lt;/strong&gt; 등이 있지만, 나머지는 추후 따로 정리해보도록 하겠다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이진트리를 구현하기 위해서는 먼저 이진트리를 구성하는 &lt;code class=&quot;language-text&quot;&gt;node&lt;/code&gt;가 필요할 것이다. 아래와 같이 생성자 함수 코드로 작성할 수 있다. 이 함수를 잘 기억해둬야 추후 순회 알고리즘을 이해할 수 있다. node의 left와 right를 갖고 있는 점을 기억해두자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;BinaryTreeNode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; value&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;left &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;right &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;노드를 만들었으면 이제 트리에 추가하기 위한 객체를 만들자. &lt;code class=&quot;language-text&quot;&gt;node&lt;/code&gt;를 만들었던 방식으로 생성자 함수를 사용해 BinaryTree 함수를 만든다. 이 BinaryTree 함수에는 root값이 null인 프로퍼티를 초기 값으로 설정한다. 이후 위의 node를 생성하면서 root에 추가하고 왼쪽과 오른쪽에 node 객체를 재할당 하는 방식으로 진행한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;BinaryTree&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_root &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;트리순회tree-traversal&quot;&gt;&lt;a href=&quot;#%ED%8A%B8%EB%A6%AC%EC%88%9C%ED%9A%8Ctree-traversal&quot; aria-label=&quot;트리순회tree traversal permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;트리순회(Tree Traversal)&lt;/h3&gt;
&lt;p&gt;트리의 경우 트리의 모든 항목을 방문하기 위해 왼쪽 포인터와 오른쪽 포인터가 존재한다고 한다. 그리고 순회 방법에는 선순위(pre-order), 후순위(post-order), 중순위(in-order), 단계순위(level-order) 순회가 있다. 이 방법 또한 차근차근 정리해 보겠다.&lt;/p&gt;
&lt;h4 id=&quot;-선순위순회-pre-order-traversal&quot;&gt;&lt;a href=&quot;#-%EC%84%A0%EC%88%9C%EC%9C%84%EC%88%9C%ED%9A%8C-pre-order-traversal&quot; aria-label=&quot; 선순위순회 pre order traversal permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;# 선순위순회 (Pre-order Traversal)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.techiedelight.com/wp-content/uploads/Preorder-Traversal.png&quot; alt=&quot;Pre-order Traversal&quot;&gt;&lt;/p&gt;
&lt;p&gt;출처: &lt;a href=&quot;https://www.techiedelight.com/wp-content/uploads/Preorder-Traversal.png&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Techie Delight&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;선순위 순회는 루트노드에서 시작해 왼쪽노드부터 차례대로 다 순회한 후 오른쪽노드 순으로 순회한다. 처음에는 코드로 이해하기 힘들었지만, 원리를 파악하면서 느낀 부분은 순회 순서와 코드 순서를 잘 이해하는 것이 코드 이해의 핵심이었다. 재귀함수의 경험이 없다보니 재귀함수를 작성하거나 이해할 때 이해의 핵심포인트를 찾으려고 노력한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;BinaryTree&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;traversePreOrder &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;funciton&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;traversePreOrderHelper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_root&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 가장 최상위인 root node를 전달해 실행&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;TraversePreOrderHelper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// (1) 인자로 받은 노드가 없을 때, 즉시 함수 종료&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// (2) 인자로 받은 노드가 있으니 값을 출력&lt;/span&gt;

    &lt;span class=&quot;token function&quot;&gt;traversePreOrderHelper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;left&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// (3) 왼쪽부터 순회해야하기 때문에&lt;/span&gt;
                                       &lt;span class=&quot;token comment&quot;&gt;// 재귀함수를 통해 모든 left &lt;/span&gt;
                                       &lt;span class=&quot;token comment&quot;&gt;// node부터 인자로 전달&lt;/span&gt;
                                       &lt;span class=&quot;token comment&quot;&gt;// 조건문으로 left가 있는지 확인을 먼저&lt;/span&gt;
                                       &lt;span class=&quot;token comment&quot;&gt;// 하는 것이 아닌 것이 바로 left를 넣어&lt;/span&gt;
                                       &lt;span class=&quot;token comment&quot;&gt;// 실행하는 것이 이해의 핵심이었다.&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;traversePreOrderHelper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;right&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// (4) 왼쪽이 끝났으면 오른쪽 node&lt;/span&gt;
                                        &lt;span class=&quot;token comment&quot;&gt;// 를 모두 순회&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;TL;DR: 위의 코드 동작&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;위의 코드를 통해 그림을 설명해보자면, 간단하게 표현한 1의 값을 갖고있는 root node &lt;code class=&quot;language-text&quot;&gt;node: 1&lt;/code&gt;을 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;traversePreOrderHelper(this._root)&lt;/code&gt; 함수의 인자로 전달해 함수를 실행한다.&lt;/li&gt;
&lt;li&gt;함수의 &lt;strong&gt;(1)&lt;/strong&gt;번 부분에서 node가 null이 아니니 바로 &lt;strong&gt;(2)&lt;/strong&gt;번이 실행되어 값이 출력된다.&lt;/li&gt;
&lt;li&gt;그리고 &lt;strong&gt;(3)&lt;/strong&gt;번 부분에서 root node의 left인 &lt;code class=&quot;language-text&quot;&gt;node: 2&lt;/code&gt;가 인자로 넘어가 &lt;code class=&quot;language-text&quot;&gt;traversePreOrderHelper(node:2)&lt;/code&gt;가 실행된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;traversePreOrderHelper&lt;/code&gt; 재귀적으로 실행되어 다시 (1), (2)번을 거쳐 (3)번 실행지점으로 도착하고 left에 &lt;code class=&quot;language-text&quot;&gt;node: 4&lt;/code&gt;가 인자로 넘어가 &lt;code class=&quot;language-text&quot;&gt;traversePreOrderHelper(node:4)&lt;/code&gt;함수가 실행된다.&lt;/li&gt;
&lt;li&gt;다시 재귀 함수를 통해 (1), (2)번을 거쳐 (3)번에서 함수를 실행하려 하지만 다음 left 노드가 null이기 때문에 &lt;code class=&quot;language-text&quot;&gt;traversePreOrderHelper(null)&lt;/code&gt;이 실행&lt;/li&gt;
&lt;li&gt;다음 함수 실행 이후 node가 없으므로 (1)번 부분에서 즉시 종료되고 (4)번이 실행되는데 right node 또한 null이기 때문에 &lt;code class=&quot;language-text&quot;&gt;traversePreOrderHelper(null)&lt;/code&gt; 실행되고 반복된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;traversePreOrderHelper(node: 4)&lt;/code&gt;의 실행은 완전 종료되고 &lt;code class=&quot;language-text&quot;&gt;traversePreOrderHelper(node:2)&lt;/code&gt;의 내부로 돌아와 (4)번이 실행되지만 right node가 null이므로 역시 즉시 종료되며 함수 &lt;code class=&quot;language-text&quot;&gt;traversePreOrderHelper(node: 2)&lt;/code&gt;의 실행도 종료된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;traversePreOrderHelper(this._root)&lt;/code&gt;의 내부로 돌아와 right node가 (4)번 함수 인자로 넘어가 &lt;code class=&quot;language-text&quot;&gt;traversePreOrderHelper(node: 3)&lt;/code&gt;이 실행된다.&lt;/li&gt;
&lt;li&gt;과정이 반복된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;좀 장황하고 길지만 쉬운 이해를 위해 풀어 정리했다.&lt;/p&gt;
&lt;h4 id=&quot;-중순위순회-pre-order-traversal&quot;&gt;&lt;a href=&quot;#-%EC%A4%91%EC%88%9C%EC%9C%84%EC%88%9C%ED%9A%8C-pre-order-traversal&quot; aria-label=&quot; 중순위순회 pre order traversal permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;# 중순위순회 (Pre-order Traversal)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/practicaldev/image/fetch/s--_qLWlFQu--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://1.bp.blogspot.com/-G2lQYbrOfLY/V8BjTVjenHI/AAAAAAAAG3A/3ycXbWoTVXoQNTNxWWmZc5of4CEaTM5IQCEw/s400/inorder_traversal%252Bin%252BJava.jpg&quot; alt=&quot;In-order Traversal&quot;&gt;
출처: &lt;a href=&quot;https://dev.to/javinpaul/how-to-implement-inorder-traversal-in-a-binary-search-tree-1787&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;DEV 블로그&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;중순위순회는 가장 왼쪽 노드, 현재노드(루트노드), 오른쪽 노드 순으로 순회한다. 위의 그림을 보면 이해가 더 빠르다. 이 중순위 또한 재귀 함수로 구현하는 것이 쉽다고 한다.&lt;/p&gt;
&lt;p&gt;코드에서 이해의 핵심 부분은 순회 순서가 가장 왼쪽부터라 할 지라도 코드에서 접근하는 첫 번째 노드는 root node이며, root node에서 가장 왼쪽을 먼저 찾아가는 것이 중요하다고 느꼈다.&lt;/p&gt;
&lt;p&gt;위의 선순위 순회에서 설명한 내용을 통해 기본적인 가닥은 이해될 것이라고 생각하여 선순위 순회의 설명보다는 간략하게 정리하겠다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;BinaryTree&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;traverseInOrder&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;travseInOrderHelper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_root&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// root 부터 시작&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;travserInOrderHelper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//(1) node가 없으면? 함수 즉시 종료&lt;/span&gt;

    &lt;span class=&quot;token function&quot;&gt;travseInOrderHelper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;left&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// (2) left 노드를 넣어 주고 함수를 재귀적 실행하면&lt;/span&gt;
                                    &lt;span class=&quot;token comment&quot;&gt;// console이 이 함수 다음에 실행되므로 가장 왼쪽&lt;/span&gt;
                                    &lt;span class=&quot;token comment&quot;&gt;// node를 먼저 찾아간다.&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// (3) 값이 출력된다.&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;travserInOrderHelper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;right&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// (4) right node를 넣어 재귀적 실행하면 다시&lt;/span&gt;
                                      &lt;span class=&quot;token comment&quot;&gt;// right node의 left가장 왼쪽을 찾아 들어간다.&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 함수는 console.log 메서드 left node를 실행하는 함수 다음에 실행되는 것이 핵심 포인트라고 생각한다. 간략하게 설명하자면,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;root 부터 &lt;code class=&quot;language-text&quot;&gt;travserInOrderHelper(root)&lt;/code&gt; 함수를 실행한다.&lt;/li&gt;
&lt;li&gt;left node가 있으므로 (2)번의 &lt;code class=&quot;language-text&quot;&gt;travserInOrderHelper(node: 4)&lt;/code&gt;실행된다. 다시 재귀 실행으로 &lt;code class=&quot;language-text&quot;&gt;travserInOrderHelper(node: 1)&lt;/code&gt;까지 실행된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;travserInOrderHelper(node: 1)&lt;/code&gt;의 left node는 null이기 때문에, 실행이 종료되고 (3)번이 실행되어 &lt;strong&gt;1&lt;/strong&gt;이 출력된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;travserInOrderHelper(node: 1)&lt;/code&gt;의 right node가 null이므로 함수는 종료된다.&lt;/li&gt;
&lt;li&gt;생략되었던 &lt;code class=&quot;language-text&quot;&gt;travserInOrderHelper(node: 2)&lt;/code&gt; 내부의 (2)번에서 실행된 함수인 &lt;code class=&quot;language-text&quot;&gt;travserInOrderHelper(node: 1)&lt;/code&gt;이 종료되었기 때문에 (3)번 console.log가 실행되어 &lt;strong&gt;2&lt;/strong&gt;가 출력된다.&lt;/li&gt;
&lt;li&gt;(4)번이 실행되어 &lt;code class=&quot;language-text&quot;&gt;travserInOrderHelper(node: 3)&lt;/code&gt;이 실행되고, &lt;code class=&quot;language-text&quot;&gt;node: 3&lt;/code&gt;의 left right가 없으므로 &lt;strong&gt;3&lt;/strong&gt;이란 값이 출력되고 종료된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;travserInOrderHelper(node: 2)&lt;/code&gt;가 완전히 종료되고 &lt;code class=&quot;language-text&quot;&gt;travserInOrderHelper(node: 4)&lt;/code&gt;의 (2)번이 끝나 (3)번이 실행되어 &lt;strong&gt;4&lt;/strong&gt;란 값이 출력된다. &lt;/li&gt;
&lt;li&gt;(4)번이 실행되며 이후 앞의 과정이 반복된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;-후순위순회-post-order-traversal&quot;&gt;&lt;a href=&quot;#-%ED%9B%84%EC%88%9C%EC%9C%84%EC%88%9C%ED%9A%8C-post-order-traversal&quot; aria-label=&quot; 후순위순회 post order traversal permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;# 후순위순회 (Post-order Traversal)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.techiedelight.com/wp-content/uploads/Postorder-Traversal.png&quot; alt=&quot;Post-order&quot;&gt;
출처: &lt;a href=&quot;https://www.techiedelight.com/postorder-tree-traversal-iterative-recursive/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Techie Delight&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;후순위 순회는 가장 왼쪽 끝의 노드부터 오른쪽, 현재노드(루트노드) 순으로 마지막 부분을 먼저 순회하는 것이다. 위의 그림의 아랫부분 설명을 보면 이해가 쉽다. root 노드가 가장 마지막에 출력된다고 이해하면 된다.&lt;/p&gt;
&lt;p&gt;후순위 순회의 코드는 if 조건문을 통해 재귀함수를 호출했다. 그리고 node의 left와 right를 모두 체크한 후 console.log를 실행해 값을 출력했다. 이를 통해 느낀점은 왼쪽으로 찾아가서 순회하는 다른 코드와 다르게 가장 마지막 순서를 찾기 위해 체크를 하고 접근하는 방식이 핵심이라고 생각했다. 언제든지 오른쪽의 depth에도 접근할 수 있는 것처럼 말이다.&lt;/p&gt;
&lt;p&gt;코드를 보자면 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;BinaryTree&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;travserPostOrder&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;traversePostOrderHelper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_root&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;travserPostOrderHelper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;left&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 이 것도 어쨌든 방향은 왼쪽에서 오른쪽이기 때문에 &lt;/span&gt;
                    &lt;span class=&quot;token comment&quot;&gt;// left node 부터 체크&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;traversePostOrderHelper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;left&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 재귀를 통해 left가 있다면 일단 &lt;/span&gt;
                                          &lt;span class=&quot;token comment&quot;&gt;// 가장 왼쪽으로 찾아 간다.&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;right&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;traversePostOrderHelper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;left&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// left가 없으면 right를 찾는다. right의&lt;/span&gt;
                                          &lt;span class=&quot;token comment&quot;&gt;// depth가 길다면, left의 depth는 없다면,&lt;/span&gt;
                                          &lt;span class=&quot;token comment&quot;&gt;// right를 계속 찾아간다.&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// left와 right node 모두 없다면 출력된다. 더 이상 검색&lt;/span&gt;
                             &lt;span class=&quot;token comment&quot;&gt;// 할 depth가 없으므로.&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;선순위 중순위의 설명 덕분에 이제는 이해가 수월할테니 자세한 설명은 생략하도록 하겠다.&lt;/p&gt;
&lt;h4 id=&quot;-단계순위순회-bfs-breadth-first-search&quot;&gt;&lt;a href=&quot;#-%EB%8B%A8%EA%B3%84%EC%88%9C%EC%9C%84%EC%88%9C%ED%9A%8C-bfs-breadth-first-search&quot; aria-label=&quot; 단계순위순회 bfs breadth first search permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;# 단계순위순회 (BFS: Breadth First Search)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://i2.wp.com/algorithms.tutorialhorizon.com/files/2015/05/Tree-Traversals-BFS-e1514854406978.png&quot; alt=&quot;BFS&quot;&gt;
출처: &lt;a href=&quot;https://algorithms.tutorialhorizon.com/breadth-first-searchtraversal-in-a-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Algorithms&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;처음 공부할때 너무 어려웠던 개념의 BFS, 단계순위순회 방식이다. 말그대로 root부터 시작해 왼쪽부터 오른쪽으로 순회하면서 차례대로 한 줄씩 내려가는 순회방식이다. 위의 그림에서는 1부터 차례대로 숫자를 순회한다고 보면 된다. (1, 2, 3, 4 …)&lt;/p&gt;
&lt;p&gt;사실 개념이 어려웠다기 보다는 코드로 구현하는 것이 어려웠다. 처음에 Stack과 Queue의 개념을 배우면서 BFS, DFS 방식을 통한 Parser를 구현한 적이 있었는데 정확하게 이해하지 못하고 찾아가며 구현했던 터라 언제든지 복습하고 또 복습할 예정이였다. 오늘이 그 복습날들 중 하나인 셈이다.&lt;/p&gt;
&lt;p&gt;이해의 핵심은 queue에 left와 right를 저장하고 반복문을 통해 다시 queue에 저장했던 node들을 선입선출 방식으로 접근해 queue에 다음 노드들을 차례대로 저장하며 하나씩 순회하는 방법이다. 추후 코드와 함께 순서를 정리하겠다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;BinaryTree&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;travserLevelOrder&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//너비 우선 검색&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; root &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_root&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// (1)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; queue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// (2)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;root&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// (3)&lt;/span&gt;

  queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;root&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// (4)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// (5)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; temp &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// (6)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;temp&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// (7)&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;temp&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;left&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;temp&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;left&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// (8)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;temp&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;right&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;temp&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;right&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// (9)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;(1)&lt;/strong&gt; 먼저 root 변수에 this.&lt;em&gt;root를 할당하여 생성한다. (불필요한 추가 작업일 수도 있기에 직접 this.&lt;/em&gt;root를 넣어도 될 것 같다.) 그리고 &lt;strong&gt;(2)&lt;/strong&gt; queue라는 배열을 하나 선언한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(3)&lt;/strong&gt; 마찬가지로 root의 값이 null이라면? 즉시 종료한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(4)&lt;/strong&gt; root에 노드가 있으니 이를 queue에 저장한다. &lt;strong&gt;&lt;em&gt;(현재: [root])&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(5)&lt;/strong&gt; 반복문의 종료 조건은 queue가 비어진 상태일 때이다. queue가 빈 상태가 되면 모든 node를 다 순회했다는 의미가 될 것이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(6)&lt;/strong&gt; root를 queue에서 빼 temp에 저장한 후 &lt;strong&gt;(7)&lt;/strong&gt; 값을 console로 출력한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(8)&lt;/strong&gt; left가 있으니 left를 queue에 저장한다. &lt;strong&gt;&lt;em&gt;(현재: [node:2])&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(9)&lt;/strong&gt; right가 있으니 right를 queue에 저장한다. &lt;strong&gt;&lt;em&gt;(현재: [node:2, node:3])&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(5)&lt;/strong&gt; queue에 데이터가 있으니 반복문이 실행되고 &lt;strong&gt;(6)&lt;/strong&gt; &lt;code class=&quot;language-text&quot;&gt;node:2&lt;/code&gt;를 temp에 저장하고 &lt;strong&gt;(7)&lt;/strong&gt; console로 출력한다. &lt;strong&gt;&lt;em&gt;(현재: [node:3])&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(8)&lt;/strong&gt; &lt;strong&gt;(9)&lt;/strong&gt; left와 right가 있으니 queue에 모두 저장한다. &lt;strong&gt;&lt;em&gt;(현재: [node:3, node:4, node:5])&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(5)&lt;/strong&gt; queue에 데이터가 있으니 반복문이 실행되고 &lt;strong&gt;(6)&lt;/strong&gt; &lt;code class=&quot;language-text&quot;&gt;node:3&lt;/code&gt;를 temp에 저장하고 &lt;strong&gt;(7)&lt;/strong&gt; console로 출력한다. &lt;strong&gt;&lt;em&gt;(현재: [node:4, node:5])&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;9&quot;&gt;
&lt;li&gt;&lt;strong&gt;(8)&lt;/strong&gt; &lt;strong&gt;(9)&lt;/strong&gt; left와 right가 있으니 queue에 모두 저장한다. &lt;strong&gt;&lt;em&gt;(현재: [node:4, node:5, node:6, node:7])&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;이후 반복된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;차근차근 이해하니 다른 순회보다 더 쉬운 것 같다. 재귀함수를 사용하는 것 보다 반복문을 사용하는 것이 쉽기 때문에 이 코드를 많이 사용하는 것으로 알고 있어 더 이해가 쉬운 것 같다.&lt;/p&gt;
&lt;p&gt;정리가 많이 길어졌기 때문에 Binary Search Tree에 대해서는 2편에서 정리해야하겠다.
자료구조는 공부할 수록 어렵긴 하지만, 이런 규칙을 찾아낸 사람들이 대단하다고 느낀다. 공부할 수록 재밌는 분야라고 생각된다. 기본기를 쌓기 위해서라도 꾸준히 정리할 예정이다.&lt;/p&gt;
&lt;h2 id=&quot;도움받은-문서&quot;&gt;&lt;a href=&quot;#%EB%8F%84%EC%9B%80%EB%B0%9B%EC%9D%80-%EB%AC%B8%EC%84%9C&quot; aria-label=&quot;도움받은 문서 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;도움받은 문서&lt;/h2&gt;
&lt;p&gt;책: &lt;a href=&quot;http://www.acornpub.co.kr/book/javascript-data-algorithms&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;자바스크립트로 하는 자료 구조와 알고리즘&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</content:encoded></item><item><title><![CDATA[조건부 렌더링 vs display none]]></title><description><![CDATA[프로젝트를 진행하면서 조건부 렌더링과 display none을 사용한 렌더링의 차이점을 정리하고자한다. 최적화를 위해 차이점을 비교하며 더 나은 렌더링 방식을 선택하려한다.]]></description><link>https://ssangq.netlify.com//posts/conditional-rendering-vs-diplay-none</link><guid isPermaLink="false">https://ssangq.netlify.com//posts/conditional-rendering-vs-diplay-none</guid><pubDate>Fri, 22 Nov 2019 19:21:09 GMT</pubDate><content:encoded>&lt;p&gt;현재 프로젝트를 진행하면서 검색 필터링 기능을 구현하고있다. 구현하다보니 필터링 주제별로 &lt;strong&gt;&lt;em&gt;4가지의 버튼&lt;/em&gt;&lt;/strong&gt;이 있고, 이 버튼에 따라 같은 형태의 내용만 다른 &lt;strong&gt;&lt;em&gt;메뉴 컴포넌트&lt;/em&gt;&lt;/strong&gt;를 렌더링해야할 필요가 있었다. 최초 설계 했을 때와 다르게 코드를 작성하면서 변경할 필요성을 느낀점과 새롭게 알게된 점에 대해 정리하고자 한다.&lt;/p&gt;
&lt;h2 id=&quot;display-none&quot;&gt;&lt;a href=&quot;#display-none&quot; aria-label=&quot;display none permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;display: none&lt;/h2&gt;
&lt;p&gt;처음 설계하면서부터 컴포넌트를 flag 변경에 따라 styled-components에 변수로 전달해 display none을 하는 방식으로 렌더링을 진행했다. 하지만 React Dev Tools로 확인했을 때, 컴포넌트가 새롭게 렌더링 될 때마다 하위 요소들이 전부 새롭게 렌더링 되는 점을 발견했다. 성능에는 눈에 띌 정도로 문제가 발생하지는 않지만, 최적화 측면에서 좋지 않다는 것을 확실히 알 수 있었다.&lt;/p&gt;
&lt;p&gt;위에 설명한 부부을 아래 사진으로 확인 할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/37759759/69438877-2de6c300-0d89-11ea-8ad4-c7f445ee3ba1.gif&quot; alt=&quot;2019-11-22-22-45-57&quot;&gt;&lt;/p&gt;
&lt;p&gt;화살표 버튼으로 해당 필터 메뉴를 Toggle 했을 땐 필터 메뉴의 상위 컴포넌트를 display none으로 숨기다보니 그 하위 컴포넌트 및 요소는 &lt;code class=&quot;language-text&quot;&gt;React.memo&lt;/code&gt;의 영향을 받아 렌더링이 다시 일어나지 않는 것 같았지만 &lt;strong&gt;(정확하지 않아 혹시 알게되면 추후 수정하도록 하겠습니다.)&lt;/strong&gt;, 버튼을 눌렀을 때는 해당 메뉴 컴포넌트 (Flag에 따라 변경되는)의 하위요소가 모두 다시 렌더링 되는 것을 확인할 수 있다. 이때 작성한 코드는 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Filter Menu부분의 최상단 컴포넌트 [FilterDetail]&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;/*
...
*/
return (
&amp;lt;ThemeProvider theme={ buttonTheme }&amp;gt;
    &amp;lt;Style.DetailWrapper filterFlag={ filterFlag }&amp;gt; //filterFlag가 화살표 버튼의 Flag
        &amp;lt;Location 
            activeBtn={ activeBtn }
            setFilterData={ setFilterData }
        /&amp;gt;
        &amp;lt;Keywords 
            activeBtn={ activeBtn }
            setFilterData={ setFilterData }
        /&amp;gt;
        &amp;lt;Recommendation
            activeBtn={ activeBtn }
            setFilterData={ setFilterData }
        /&amp;gt;
        &amp;lt;Level 
            activeBtn={ activeBtn }
            setFilterData={ setFilterData }
        /&amp;gt;
/*
...
*/&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하위컴포넌트 중 하나인 [Location] (모든 컴포넌트의 html 구조는 동일)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;return (
&amp;lt;Style.RecommendWrapper 
  activeBtn={ activeBtn } // activeBtn이 주제별 버튼의 Flag
  className=&amp;#39;dropdown__menus&amp;#39;
&amp;gt;
  { dropdownList }
&amp;lt;/Style.RecommendWrapper&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Flag에 따라 변경되는 Style 부분&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;display: ${({ filterFlag }) =&amp;gt; !filterFlag &amp;amp;&amp;amp; &amp;#39;none&amp;#39;};
display: ${({ activeBtn }) =&amp;gt; activeBtn !== &amp;#39;recommendation&amp;#39; &amp;amp;&amp;amp; &amp;#39;none&amp;#39; };&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;display none은 DOM Tree에 반영은 되지만 Render Tree에 반영되지 않는 특성이 있다. 이 때문에 당연히 개발자 도구에서 Filter Menu 컴포넌트들이 추가된 것을 확인할 수 있다. (Location, Keywords, Recommendation, Level)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/37759759/69441170-8750f100-0d8d-11ea-8319-d55d2c13c646.JPG&quot; alt=&quot;displayNone&quot;&gt;&lt;/p&gt;
&lt;p&gt;React Dev Tools &lt;code class=&quot;language-text&quot;&gt;Components&lt;/code&gt; Tab에서도 Rendering이 이미 되어 있는 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/37759759/69441362-edd60f00-0d8d-11ea-8da4-54874669a01f.JPG&quot; alt=&quot;displayNone2&quot;&gt;&lt;/p&gt;
&lt;p&gt;당연하겠지만, DOM TREE에 있는 것은 이미 자원을 소비하고 있는 것이라고 생각했다. 또한 불필요하게 하위 요소를 포함한 모든 컴포넌트의 Re-rendering이 빈번하게 일어난다면, 이 또한 최적화가 필요할 것이라고 생각했다. 그렇게 조건부 렌더링으로 변경하게 되었다.&lt;/p&gt;
&lt;h2 id=&quot;conditional-rendering-조건부-렌더링&quot;&gt;&lt;a href=&quot;#conditional-rendering-%EC%A1%B0%EA%B1%B4%EB%B6%80-%EB%A0%8C%EB%8D%94%EB%A7%81&quot; aria-label=&quot;conditional rendering 조건부 렌더링 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Conditional Rendering (조건부 렌더링)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.reactjs.org/docs/conditional-rendering.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;조건부 렌더링&lt;/a&gt;은 쉽게 말해서 &lt;code class=&quot;language-text&quot;&gt;return flag &amp;amp;&amp;amp; &amp;lt;Component /&amp;gt;&lt;/code&gt;와 같은 방법으로 flag가 true일 때 컴포넌트를 Rendering 하는 방법이다. 조건부 렌더링을 적용하기 전에 예상했던 것은 조건부 렌더링은 조건에 따라 컴포넌트 또는 요소를 Rendering 해주기 때문에 &lt;code class=&quot;language-text&quot;&gt;display: none&lt;/code&gt;의 방식과 같이 DOM Tree에 추가되는 현상은 없을 것으로 판단했다. 그렇게 적용을 하고 난 결과는 내 예상과 같았다.&lt;/p&gt;
&lt;p&gt;아래의 사진에서 각 Menu 컴포넌트의 하위요소는 다시 Re-rendering이 발생하지 않는 것을 볼 수 있다.
&lt;img src=&quot;https://user-images.githubusercontent.com/37759759/69442376-d861e480-0d8f-11ea-80fa-711726e1d598.gif&quot; alt=&quot;2019-11-22-23-17-41&quot;&gt;&lt;/p&gt;
&lt;p&gt;각 Menu 컴포넌트는 당연히 새롭게 렌더링이 되는 것이기 때문에 Re-rendering이 되는 것이 맞지만 내부 요소들은 React.memo를 통해 memoized된 상태이기 때문에 Re-rendering이 발생하지 않는 다고 생각한다.&lt;/p&gt;
&lt;p&gt;다음은 DOM의 구조를 확인할 수 있다.
&lt;img src=&quot;https://user-images.githubusercontent.com/37759759/69442733-6d64dd80-0d90-11ea-9d55-bd6e68939367.JPG&quot; alt=&quot;Conditional1&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;display: none&lt;/code&gt;의 방식에서 4개의 컴포넌트가 모두 렌더링된 것과는 다르게 Menu 컴포넌트 하나와 버튼 UI만 Rendering된 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;하지만 조금 예상 밖이었던 것은, 아래 사진과 같이 React Dev Tools의 &lt;code class=&quot;language-text&quot;&gt;Components&lt;/code&gt; Tab에서는 4개의 컴포넌트를 확인할 수 있는 점이였다..
&lt;img src=&quot;https://user-images.githubusercontent.com/37759759/69443153-33480b80-0d91-11ea-829c-32e4c091711a.png&quot; alt=&quot;2019-11-22-23-20-46&quot;&gt;&lt;/p&gt;
&lt;p&gt;리팩토링을 위해 코드를 점검해보니, &lt;code class=&quot;language-text&quot;&gt;display: none&lt;/code&gt; 방식의 위와 같은 형태처럼 flag를 넘겨주고 각 Menu 컴포넌트 내에서 조건부 렌더링을 걸어준 것이 문제라는 것을 발견했다.&lt;/p&gt;
&lt;p&gt;아래 그 문제의 코드를 확인할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;Location 
    activeBtn={ activeBtn }
    setFilterData={ setFilterData }
/&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;return activeBtn === &amp;#39;location&amp;#39; &amp;amp;&amp;amp; (
    &amp;lt;div
      className=&amp;#39;dropdown__menus&amp;#39;
    &amp;gt;
      &amp;lt;FilterMenu 
        menuTitle=&amp;#39;도시명&amp;#39;
        onChange={ ({ target }) =&amp;gt; setCity(target.value) }
        optionValues={ cities }
      /&amp;gt;
      &amp;lt;FilterMenu 
        menuTitle=&amp;#39;군/구&amp;#39;
        onChange={ ({ target }) =&amp;gt; setGu_nm(target.value)}
        optionValues={ locationDetail[city] }
      /&amp;gt;
    &amp;lt;/div&amp;gt;
  );&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;해당-ui-최상단-컴포넌트에서-conditional-rendering-적용하기&quot;&gt;&lt;a href=&quot;#%ED%95%B4%EB%8B%B9-ui-%EC%B5%9C%EC%83%81%EB%8B%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C-conditional-rendering-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0&quot; aria-label=&quot;해당 ui 최상단 컴포넌트에서 conditional rendering 적용하기 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;해당 UI 최상단 컴포넌트에서 Conditional Rendering 적용하기&lt;/h2&gt;
&lt;p&gt;이 문제를 해결하기 위해서 Menu 컴포넌트들을 관리하는 최상단 컴포넌트 [FilterDetail] 컴포넌트에서 조건부 렌더링을 적용시키려고 시도했다. 결과는 예상과 같았다. 다른 부분은 모두 위의 설명과 같았고, 문제시 되었던 React Dev Tools &lt;code class=&quot;language-text&quot;&gt;Components&lt;/code&gt; Tab에서의 4개 컴포넌트가 렌더된 것은 명확하게 해결한 것을 확인할 수 있었다.&lt;/p&gt;
&lt;p&gt;먼저 코드는 아래와 같이 useMemo와 Switch 문을 활용해 작성했다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const filterRenderer = useMemo(() =&amp;gt; {
    switch(activeBtn) { // 각 Menu 컴포넌트에 대한 Flag
      case &amp;#39;location&amp;#39;:
        return (
          &amp;lt;Location 
            setFilterData={ setFilterData }
          /&amp;gt;
        );
      case &amp;#39;keywords&amp;#39;:
        return(
          &amp;lt;Keywords 
            setFilterData={ setFilterData }
          /&amp;gt;
        );
      case &amp;#39;recommendation&amp;#39;:
        return (
          &amp;lt;Recommendation
            setFilterData={ setFilterData }
          /&amp;gt;
        );
      case &amp;#39;level&amp;#39;:
        return (
          &amp;lt;Level 
            setFilterData={ setFilterData }
          /&amp;gt;
        );
      default:
        break;
    }
  }, [activeBtn]);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt; return filterFlag &amp;amp;&amp;amp; ( // 화살표 버튼에 대한 Flag
    &amp;lt;ThemeProvider theme={ buttonTheme }&amp;gt;
      &amp;lt;Style.DetailWrapper&amp;gt;
        { filterRenderer }
/*
.
.
.
*/&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;아래는 그 결과에 따른 Render 결과이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/37759759/69444112-0694f380-0d93-11ea-8263-1ddb07df0b61.JPG&quot; alt=&quot;Conditional2&quot;&gt;&lt;/p&gt;
&lt;p&gt;위의 사진에서 보시다시피 Location 하나의 Component만 Rendering 되었다.&lt;/p&gt;
&lt;p&gt;하지만, React Dev Tools의 Profiler Tab을 확인했을 때는 &lt;code class=&quot;language-text&quot;&gt;Context.consumer&lt;/code&gt; 컴포넌트의 호출시간이 각 Menu 컴포넌트에서 Flag를 사용했을 때 보다 길게 나왔는데, 사실 Profiler의 사용법은 아직 거의 습득하지 못해서 추후 학습하며 수정이 필요하다면 수정해 나가도록 해야겠다.&lt;/p&gt;
&lt;h2 id=&quot;rendering의-차이점을-확인해보면서&quot;&gt;&lt;a href=&quot;#rendering%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%84-%ED%99%95%EC%9D%B8%ED%95%B4%EB%B3%B4%EB%A9%B4%EC%84%9C&quot; aria-label=&quot;rendering의 차이점을 확인해보면서 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Rendering의 차이점을 확인해보면서..&lt;/h2&gt;
&lt;p&gt;일단 컴포넌트를 호출해서 그 컴포넌트 안에서 조건부 렌더링으로 처리한 것이기 때문에 어쩌면 너무나도 당연한 문제였을 수도 있다. 하지만 경험이 없었던 터라 이런 부분에 대해 명확하게 머릿속에 새긴 기회가 되어 매우 좋았고, 정리하면서 조금은 미흡했던 개념을 잡을 수 있어 좋았다. 아직 프로젝트에 이런 Rendering이 최적화되지 못한 컴포넌트들이 많은데, Filter UI를 완성하고 나면 Refactoring의 시간을 갖는 것이 좋을 것 같다.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</content:encoded></item><item><title><![CDATA[3개 숫자의 합이 소수인가?!]]></title><description><![CDATA[배열 안의 숫자 중 3개를 무작위로 더한 값이 소수인지 판별하는 알고리즘 문제이다. 해당 문제는 프로그래머스에서 제공하는 문제다.]]></description><link>https://ssangq.netlify.com//posts/prime-number-of-sum-of-three-numbers</link><guid isPermaLink="false">https://ssangq.netlify.com//posts/prime-number-of-sum-of-three-numbers</guid><pubDate>Tue, 19 Nov 2019 19:23:48 GMT</pubDate><content:encoded>&lt;h2 id=&quot;문제&quot;&gt;&lt;a href=&quot;#%EB%AC%B8%EC%A0%9C&quot; aria-label=&quot;문제 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;문제&lt;/h2&gt;
&lt;p&gt;주어진 숫자 중 3개의 수를 더했을 때 소수가 되는 경우의 개수를 구하려고 합니다. 숫자들이 들어있는 배열 nums가 매개변수로 주어질 때, nums에 있는 숫자들 중 서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 return 하도록 solution 함수를 완성해주세요.&lt;/p&gt;
&lt;h2 id=&quot;제한조건&quot;&gt;&lt;a href=&quot;#%EC%A0%9C%ED%95%9C%EC%A1%B0%EA%B1%B4&quot; aria-label=&quot;제한조건 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;제한조건&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;nums에 들어있는 숫자의 개수는 3개 이상 50개 이하입니다.&lt;/li&gt;
&lt;li&gt;nums의 각 원소는 1 이상 1,000 이하의 자연수이며, 중복된 숫자가 들어있지 않습니다.&lt;/li&gt;
&lt;li&gt;가능한 경우의 수를 return 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;생각한-풀이-방법&quot;&gt;&lt;a href=&quot;#%EC%83%9D%EA%B0%81%ED%95%9C-%ED%92%80%EC%9D%B4-%EB%B0%A9%EB%B2%95&quot; aria-label=&quot;생각한 풀이 방법 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;생각한 풀이 방법&lt;/h2&gt;
&lt;p&gt;먼저 배열의 값을 3개 뽑기 위해 for문을 3중첩으로 해야겠다고 생각했다. 더 좋은 방법이 있을 것으로 생각되지만, 시작 Index가 첫 번째 요소의 +1인 총 3개의 숫자가 필요했고, 총 회전 수가 length보다 -2, -1, 0 차이나도록 설정하는데 가장 적합한 방법이 for문으로 생각되었다.
이 후, 배열의 요소는 중복되지 않기 때문에 세 개 숫자의 합 최소는 6이므로 소수 중에는 짝수가 2밖에 없고, 2를 제외한 소수는 짝수가 아니기 때문에 2로 나눠질 경우 바로 다음 경우의 수를 검사하도록 설정했다.
마지막으로 세개의 숫자 합이 소수인지 판단하는 함수를 생성했다. 함수의 로직은 소수는 1과 자기 자신 외에 나눠지는 숫자가 없으므로, for문을 통해 2부터 세개의 숫자 합을 나눠서 본인외에 나눠지는 수가 없으면 true를 반환하도록 설정했다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function solution(nums) {
    let answer = 0;
    const numsLen = nums.length;

    for(let i = 0; i &amp;lt; numsLen - 2; i++){
        for(let j = i + 1; j &amp;lt; numsLen - 1; j++) {
            for (let k = j + 1; k &amp;lt; numsLen; k++) {
                const numSum = nums[i] + nums[j] + nums[k];
                if(numSum % 2 === 0) continue;
                else if(isPrime(numSum)) answer++;
            }
        }
    }

    return answer;
}

function isPrime(num) {
    let isPrime = false;
    const dividedNums = [];

    for(let i = 2; i &amp;lt;= num; i++) {
        const restOfDivision = num % i;
        if(restOfDivision === 0) dividedNums.push(i);
    }
    return dividedNums.length === 1;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</content:encoded></item><item><title><![CDATA[올바른 스킬 알고리즘 풀이]]></title><description><![CDATA[프로그래머스 알고리즘 문제를 풀고 이를 정리하였다. 주제는 스킬 트리로, 쉽게 게임에서 선행 스킬을 배워야만 다음 스킬을 배울 수 있는 알고리즘으로 제공되는 여러가지 Skill Tree가 제시된 Skill 순서에 맞는지 확인하는 알고리즘이다. 해당 문제는 프로그래머스에서 제공하는 문제다.]]></description><link>https://ssangq.netlify.com//posts/algorithm-right-skill-trees</link><guid isPermaLink="false">https://ssangq.netlify.com//posts/algorithm-right-skill-trees</guid><pubDate>Tue, 19 Nov 2019 14:11:11 GMT</pubDate><content:encoded>&lt;h2 id=&quot;문제&quot;&gt;&lt;a href=&quot;#%EB%AC%B8%EC%A0%9C&quot; aria-label=&quot;문제 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;문제&lt;/h2&gt;
&lt;p&gt;함수의 인자로 &lt;code class=&quot;language-text&quot;&gt;skill&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;skill_trees&lt;/code&gt;를 받고, skill은 선행되어야 할 skill들의 순서이며, skill&lt;em&gt;trees는 유저가 찍으려는 skill 순서도를 나타낸 결과물의 배열이라고 생각하면 될 것같다.
예를 들어, &lt;code class=&quot;language-text&quot;&gt;skill = &amp;#39;CBD&amp;#39;&lt;/code&gt; 라면 C -&gt; B -&gt; D 순서로 스킬이 반드시 찍혀야되며, `skill&lt;/em&gt;trees = [“BACDE”, “CBADF”, “AECB”, “BDA”]`에서 올바른 스킬트리는 2개이다. 다른 스킬들은 어떻게 찍히던 상관 없다.&lt;/p&gt;
&lt;h2 id=&quot;제한조건&quot;&gt;&lt;a href=&quot;#%EC%A0%9C%ED%95%9C%EC%A1%B0%EA%B1%B4&quot; aria-label=&quot;제한조건 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;제한조건&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;스킬은 알파벳 대문자로 표기하며, 모든 문자열은 알파벳 대문자로만 이루어져 있습니다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스킬 순서와 스킬트리는 문자열로 표기합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;예를 들어, C → B → D 라면 CBD로 표기합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;선행 스킬 순서 skill의 길이는 1 이상 26 이하이며, 스킬은 중복해 주어지지 않습니다.&lt;/li&gt;
&lt;li&gt;skill_trees는 길이 1 이상 20 이하인 배열입니다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;skill_trees의 원소는 스킬을 나타내는 문자열입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;skill_trees의 원소는 길이가 2 이상 26 이하인 문자열이며, 스킬이 중복해 주어지지 않습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;생각한-풀이-방법&quot;&gt;&lt;a href=&quot;#%EC%83%9D%EA%B0%81%ED%95%9C-%ED%92%80%EC%9D%B4-%EB%B0%A9%EB%B2%95&quot; aria-label=&quot;생각한 풀이 방법 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;생각한 풀이 방법&lt;/h2&gt;
&lt;p&gt;객체에 skill 프로퍼티를 생성하고 반복문으로 skill tree들과 비교도 해보며 여러가지 시행착오를 겪었지만, 동료와 함께 풀면서 stack이나 queue를 사용하는 것이 어떤지 고민했고, queue를 사용해 하나씩 뽑아서 만약 skill tree에 있다면 그 선행 skill과 맞는지 비교하는 방법으로 풀었다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function solution(skill, skill_trees) {
    let answer = 0;

    skill_trees.forEach(skillTree =&amp;gt; {
        const skillStack = [...skill];

        const isRightTree = [...skillTree].every((skillUnit) =&amp;gt; {
            if(skillStack.indexOf(skillUnit) &amp;gt; -1) {
                const nextSkill = skillStack.shift();
                return nextSkill === skillUnit;
            }
            return true;
        });

        if(isRightTree) answer++;
    });

    return answer;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</content:encoded></item><item><title><![CDATA[Redux를 파헤쳐보자 (삽으로...) 두 번째]]></title><description><![CDATA[Redux에 대해 배운점을 정리하려한다. Redux를 프로젝트에 적용하려고 하지만 아직 적용 전이다. 일단 학습한 내용을 정리하고 이를 토대로 프로젝트에 대입하며 현재 포스트를 수정해 나갈 계획이다. 이번에는 앞의 내용에 추가하여 redux-thunk를 정리하겠다.]]></description><link>https://ssangq.netlify.com//posts/react-redux-thunk</link><guid isPermaLink="false">https://ssangq.netlify.com//posts/react-redux-thunk</guid><pubDate>Mon, 18 Nov 2019 16:24:21 GMT</pubDate><content:encoded>&lt;p&gt;Redux Thunk &lt;code class=&quot;language-text&quot;&gt;redux-thunk&lt;/code&gt;는 Redux의 미들웨어이며, 비동기를 처리하기 위해 사용한다고 한다. redux-thunk를 사용하기 전에 action 함수를 통해 비동기 처리를 하는 것이 어떤 문제가 발생하는지 확인하도록 하겠다.&lt;/p&gt;
&lt;h2 id=&quot;문제상황---state가-data를-읽지-못한다&quot;&gt;&lt;a href=&quot;#%EB%AC%B8%EC%A0%9C%EC%83%81%ED%99%A9---state%EA%B0%80-data%EB%A5%BC-%EC%9D%BD%EC%A7%80-%EB%AA%BB%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;문제상황   state가 data를 읽지 못한다 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;문제상황 - state가 data를 읽지 못한다.&lt;/h2&gt;
&lt;p&gt;아래와 같이 action함수에서 비동기 처리를 하면 어떤 일이 발생할까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;export const fetchPosts = async () =&amp;gt; {
  // Bad approach!!!
  const response = await jsonPlaceholder.get(&amp;#39;/posts&amp;#39;);

  return {
    type: &amp;#39;FETCH_POSTS&amp;#39;,
    payload: response
  };
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;일반적으로는 &lt;code class=&quot;language-text&quot;&gt;async&lt;/code&gt; 안에서 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt; 를 통해 제대로 값을 전달 받아 payload의 value로 전달해 완벽한 객체를 전달 할 것이라고 생각한다. 하지만 해당 action으로 dispatch를 진행했을 때 화면은 아래와 같다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/37759759/69032591-3e610b80-0a20-11ea-9b28-4c71543e800a.JPG&quot; alt=&quot;redux 캡쳐&quot;&gt;&lt;/p&gt;
&lt;p&gt;처음에는 내가 return하는 것이 object인데… 대체 뭐지? 라고 생각했다. 아무리 봐도 제대로 준 것이 맞다. 특히 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt; 는 비동기에서 다음 작업이 진행될 동안 기다려주는 함수가 아닌가? Udemy에서 학습하면서 이에 대한 원인을 알 수 있었다. 아래 코드는 &lt;a href=&quot;https://babeljs.io/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;babelio&lt;/a&gt;을 통해 찾아낸 위의 fetchPosts 함수의 polyfill을 이해하기 쉽게 재 해석한 것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 아래 처럼 async await는 본래 fetch로 가져온 데이터를 먼저 리턴하고 
//이후 본래 우리가 리턴하려던 값을 주기때문에 원하는 작동이 안된다.
export const fetchPosts = async () =&amp;gt; {
  switch(somthing) {
    case 0:
      return jsonPlaceholder.get(&amp;#39;/posts&amp;#39;);

    case 1:
        return {
          type: &amp;#39;FETCH_POSTS&amp;#39;,
          payload: response
        };
  };
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위에서 볼 수 있 듯 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt; 부분인 jsonPlaceholder.get(‘/posts)를 먼저 return한다. return한 내용은 object가 아닌 특정 값이 먼저 return 될 것이다. 그리고 나서 &lt;code class=&quot;language-text&quot;&gt;async&lt;/code&gt; 함수는 의도했던 객체를 return 하려 하지만, 이미 처음 return한 내용으로 인해 오류가 발생하게 된다. 그렇기 때문에 &lt;code class=&quot;language-text&quot;&gt;redux-thunk&lt;/code&gt;를 사용해 dispatch를 action의 내부에서 받아 사용하도록 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Action (Thunk 함수)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import jsonPlaceholder from &amp;#39;../apis/jsonPlaceholder&amp;#39;;
// import action 으로 action 함수를 바다왔을 때&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;export const fetchPosts = () =&gt; async dispatch =&gt; {
const response = await jsonPlaceholder.get(‘/posts’);&lt;/p&gt;
&lt;p&gt;  dispatch({ type: ‘FETCH_POSTS’, payload: response })
// dispatch(action()) 이렇게도 사용하지만, 그냥 dispatch의 인자에 객체를 넣어 줘도 괜찮다.
};&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- Action을 사용하는 Component&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;import React, { Component } from ‘react’;
import { connect } from ‘react-redux’;
import { fetchPosts } from ‘../actions’;&lt;/p&gt;
&lt;p&gt;class PostList extends Component {
componentDidMount() {
this.props.fetchPosts();
};&lt;/p&gt;
&lt;p&gt;  render() {
console.log(this.props.posts);
return (
&lt;div&gt;
Post List
&lt;/div&gt;
);
};
};&lt;/p&gt;
&lt;p&gt;const mapStateToProps = (state) =&gt; {
return { posts: state.posts };
}&lt;/p&gt;
&lt;p&gt;export default connect(
mapStateToProps,
{ fetchPosts }
)(PostList);&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- Root&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;import React from ‘react’;
import ReactDOM from ‘react-dom’;
import { Provider } from ‘react-redux’;
import { createStore, applyMiddleware } from ‘redux’;
import thunk from ‘redux-thunk’;&lt;/p&gt;
&lt;p&gt;import App from ‘./components/App’;
import reducers from ‘./reducers’;&lt;/p&gt;
&lt;p&gt;const store = createStore(reducers, applyMiddleware(thunk));&lt;/p&gt;
&lt;p&gt;ReactDOM.render(
&amp;#x3C;Provider store={ store }&gt;
&lt;App /&gt;
&lt;/Provider&gt;,
document.querySelector(‘#root’)
);&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;먼저 `Root`의 코드를 보면 createStore로 store를 만들 때 두번째 인자(여기서는 preloadedState 부분이 아닌 **enhancer**부분)에 `applyMiddleware()`를 넣어주고 적용할 미들웨어인 react-thunk를 인자로 넣어 주었다. Action 부분은 type과 payload 값을 담은 객체를 return 하는 것이 아닌, dispatch를 실행해 직접 상태 변경을 진행 하고 있다. 이후 component에서는 단순히 기존 사용하던 방식과 같이 호출하여 사용한다.

Redux Middleware와 관련된 API 및 library의 내부 동작 원리를 설명하려면 공부가 더욱 필요한 것 같다. 함수형 프로그래밍 기반의 코드이기 때문에 아직은 이해가 부족하기 때문에 더 학습 한 뒤에 따로 포스팅해야겠다.

그리고 위의 코드 또한 하나의 사용 예시일 뿐 다양한 방법으로 사용할 수 있는 것 같다. 앞으로 경험해보지 못한 부분에 대해서는 다양한 코드를 리뷰해보며 사용법을 익히도록 해야겠다.

___

&amp;gt; 공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.

---&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Redux를 파헤쳐보자 (삽으로...) 첫 번째]]></title><description><![CDATA[Redux에 대해 배운점을 정리하려한다. Redux를 프로젝트에 적용하려고 하지만 아직 적용 전이다. 일단 학습한 내용을 정리하고 이를 토대로 프로젝트에 대입하며 현재 포스트를 수정해 나갈 계획이다.]]></description><link>https://ssangq.netlify.com//posts/react-redux</link><guid isPermaLink="false">https://ssangq.netlify.com//posts/react-redux</guid><pubDate>Mon, 18 Nov 2019 13:14:21 GMT</pubDate><content:encoded>&lt;p&gt;React Hooks를 사용하면서 state 관리는 useReducer와 ContextAPI를 사용했다. &lt;strong&gt;Redux&lt;/strong&gt;, &lt;strong&gt;MobX&lt;/strong&gt; 가 가장 뜨거운 state 관리 library라고 하지만, hooks에 내장되어 있는 API를 사용함에 있어 크게 불편하거나 다른 상태관리 library를 사용해야겠다는 필요성을 크게 느끼지는 못했다. 그래도 가장 많이 사용하는 library기도 하고 학습차원에서 어떤 편리함이 있는지, 어떤 차이가 있는지를 학습하고 싶어 가장 사용량이 많은 Redux를 학습했다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;단순히 ‘사람들이 많이 쓰니까’라는 이유라기 보다는 사람들이 많이 사용하는데는 그만큼 장점이 많다는 것을 입증하는 것이고 그와 함께 사용할 수 있는 라이브러리가 많고 계속 발전해 나간다는 것을 예상할 수 있다고 생각한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;redux의-특징&quot;&gt;&lt;a href=&quot;#redux%EC%9D%98-%ED%8A%B9%EC%A7%95&quot; aria-label=&quot;redux의 특징 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Redux의 특징?&lt;/h2&gt;
&lt;p&gt;Redux는 Event Sourcing 패턴과 Functional Programming을 결합한 라이브러리 형태라고한다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;간단하게 &lt;strong&gt;Event Sourcing 패턴이 무엇&lt;/strong&gt;인지 찾아본 것을 정리하자면 이벤트가 발생할 때마다 결과 값을 통해 지속적으로 상태를 변경하거나 어떤 조작을 하는 것이 아닌, 최종 이벤트 이후 행동이 이뤄지도록 이벤트를 모두 저장한 후 마지막에 한번에 실행함으로써 최종 결과 값만을 얻어내는 방식이다. 예를 들어, 쇼핑 장바구니에서 물건을 추가, 삭제, 새로운 물건을 구매 하는 행위들을 이벤트 발생 시점마다 처리해주는 것이 아니라 이벤트를 저장해 뒀다가 나중에 한번에 처리해서 마지막으로 구매할 물품에 대한 값만 얻어내는 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redux는 3가지의 기본 원칙이 있다고 한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Single Source of Truth (SSOT) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모든 state가 단 하나의 store를 통해서 관리된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Read-only state&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state를 직접 수정할 수 없다. (Reducer를 사용해서 수정)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Changes from pure functions&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;순수 함수를 통해 수정된다. 기존 값을 변경하는 것이 아닌 새로운 값을 return해야 하는 형식과도 연결성이 있다고 생각.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;redux의-구조&quot;&gt;&lt;a href=&quot;#redux%EC%9D%98-%EA%B5%AC%EC%A1%B0&quot; aria-label=&quot;redux의 구조 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Redux의 구조?&lt;/h2&gt;
&lt;p&gt;Redux는 가장 main이 되는 3가지와 redux의 상태관리를 도와주는 1가지, 총 4가지의 구조로 이뤄져있다고 생각한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Action: state를 어떻게 변경시킬지 추상화한 표현. 단순 객체로 type 프로퍼티를 꼭 갖고 있어야한다.&lt;/li&gt;
&lt;li&gt;Reducer: 액션에서 추상화된 로직과 그 type에 따라 이전 state와 action을 parameter로 받은 후 실제 다음 state를 반환하는 함수이다.&lt;/li&gt;
&lt;li&gt;Store: state를 저장하고 읽을 수 있게 하며 액션을 보내거나 상태의 변화를 감지할 수 있도록 API를 제공.&lt;/li&gt;
&lt;li&gt;Middleware: Redux의 상태 변화 과정 사이에서 서드파티 확장을 사용할 수 있는 지점을 제공.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-media-1.freecodecamp.org/images/1*VLQNO9Apn9qfm6BPYXG8TA.png&quot; alt=&quot;Redux_Process&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;redux의-사용법-기본&quot;&gt;&lt;a href=&quot;#redux%EC%9D%98-%EC%82%AC%EC%9A%A9%EB%B2%95-%EA%B8%B0%EB%B3%B8&quot; aria-label=&quot;redux의 사용법 기본 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Redux의 사용법 (기본)&lt;/h2&gt;
&lt;p&gt;Udemy 강좌를 보면서 학습했던 학습 코드를 예시로 간단히 정리해보겠다. 아래 학습 내용은 React Class Component를 사용해 Redux를 사용한 예시이다.&lt;/p&gt;
&lt;h3 id=&quot;action&quot;&gt;&lt;a href=&quot;#action&quot; aria-label=&quot;action permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Action&lt;/h3&gt;
&lt;p&gt;Action을 예시코드로 확인해보려한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// Action Creator
export const selectSong = (song) =&amp;gt; {
  //.. any logic
  // Return an action
  return {
    type: &amp;#39;SONG_SELECTED&amp;#39;,
    payload: song
  };
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;일반적으로 action에서 받는 인자를 payload에 저장하면, payload는 reducer로 전달되어 상태 변경에 영향을 끼친다. payload는 변경된 상태를 저장하는 property 명으로 사용된다. 물론 인자를 받지 않도록 설계될 수도 있고, 직접 payload 값을 설정해 줄 수도 있다. (boolean) 같은 경우.&lt;/p&gt;
&lt;h3 id=&quot;reducer&quot;&gt;&lt;a href=&quot;#reducer&quot; aria-label=&quot;reducer permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reducer&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import { combineReducers } from &amp;#39;redux&amp;#39;;

const songsReducer = () =&amp;gt; {
  return [
    { title: &amp;#39;No Scrubs&amp;#39;, duration: &amp;#39;4:05&amp;#39; },
    { title: &amp;#39;Macarena&amp;#39;, duration: &amp;#39;2:30&amp;#39; },
    { title: &amp;#39;All Star&amp;#39;, duration: &amp;#39;3:15&amp;#39; },
    { title: &amp;#39;I Want it That Way&amp;#39;, duration: &amp;#39;1:45&amp;#39; },
  ];
};

const selectedSongReducer = (selectedSong=null, action) =&amp;gt; {
  switch(action.type) {
    case &amp;#39;SONG_SELECTED&amp;#39;:
      return action.payload;
    default:
      return selectedSong;
  };
};

export default combineReducers({
  songs: songsReducer,
  selectedSong: selectedSongReducer
});&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;첫 번째로 봐야할 점은 Reducer는 두개가 될 수도있고 3개가 될 수도 있지만, 결국 combineReducers를 통해 각각의 객체의 프로퍼티로 저장해 하나로 합친 모습을 볼 수 있다. 이를 통해 Redux 특징인 SSOT 성격을 지키려는 노력을 볼 수 있다. 물론 combineReducer를 사용하지 않고 custom function으로 작성하는 방법도 있겠지만, 편하게 combineReducer 유틸리티를 사용하는 것이 좋을 것으로 생각한다.&lt;/p&gt;
&lt;p&gt;두 번째로, 첫번째 &lt;code class=&quot;language-text&quot;&gt;songsReducer&lt;/code&gt;는 단순히 배열 값을 return하는 함수이지만, &lt;code class=&quot;language-text&quot;&gt;selectedSongReducer&lt;/code&gt;는 action의 type에 따른 상태를 변화해 주는 함수이다. 이상하겠지만, &lt;code class=&quot;language-text&quot;&gt;songsReducer&lt;/code&gt;는 단순히 state를 제공해주기만 할 뿐, 변화가 없기 때문에 위와 같이 사용했다고 봐도 무방할 것 같다.&lt;/p&gt;
&lt;p&gt;세 번째로, &lt;code class=&quot;language-text&quot;&gt;selectedSongReducer&lt;/code&gt;의 첫 번째 인자인 selectedSong의 경우는 해당 reducer의 state로, 초기 값이 있는 경우 외부에 명확하게 작성 후 변수를 참조하여 사용하기도 한다. 만약 없는 경우 undefeined라고 두면 되지 않을까? 굳이 &lt;code class=&quot;language-text&quot;&gt;default parameter&lt;/code&gt;를 사용할 필요가 있을까 생각하기도 할텐데, 이는 Redux에서 초기 state가 undefined일 경우 오류가 설계된 것 같았고 (직접 사용해본 결과), 값이 없는 경우 반드시 null값으로 설정하도록 권장했다.&lt;/p&gt;
&lt;h3 id=&quot;store&quot;&gt;&lt;a href=&quot;#store&quot; aria-label=&quot;store permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Store&lt;/h3&gt;
&lt;p&gt;이제 만든 Reducer를 바탕으로 Store를 만들어야한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import React from &amp;#39;react&amp;#39;;
import ReactDOM from &amp;#39;react-dom&amp;#39;;
import { Provider } from &amp;#39;react-redux&amp;#39;; 
import { createStore } from &amp;#39;redux&amp;#39;;

import App from &amp;#39;./components/App&amp;#39;;
import reducers from &amp;#39;./reducers&amp;#39;;

ReactDOM.render(
  &amp;lt;Provider store={ createStore(reducers) }&amp;gt;
    &amp;lt;App /&amp;gt;
  &amp;lt;/Provider&amp;gt;, 
  document.querySelector(&amp;#39;#root&amp;#39;)
);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;React와 관련된 코드가 많이 섞여있지만, redux와 react-redux와 관련된 두개의 코드를 함께 보면 좋을 것 같다.&lt;/p&gt;
&lt;p&gt;먼저, Provider Component의 경우는 react-redux에서 제공하는 API로 context API와 같은 역할을 한다. Component를 감싸 그 Component 포함 하위 Component에게 Store에 접근 할 수 있도록 제공하는 것이다. 이를 통해 하위 Component에서 store라는 props 명으로 접근할 수 있도록 설정했고, 실제로 Store를 만드는 것은 redux에서 제공하는 createStore라는 API에서 제공한다.&lt;/p&gt;
&lt;p&gt;createStore는 아래와 같이 이뤄져있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;createStore(reducer, [preloadedState], [enhancer])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;첫번째 인자로 우리가 combineReducer로 합친 reducer를 import해서 넣어주고, 두 번째 인자부터는 Optional이며 두 번째 인자로 초기 값을 설정해 줄 수가 있다. 만약 없다면 Reducer에서 설정한 기본값이 초기 상태가 된다. 만약 설정 한다면 Reducer와 맞물리도록 같은 Key값을 가져야한다. 세번째 인자로는 Store Enhancer로 말 그대로 스토어에 어떠한 기능을 추가할 때 이를 argument로 넣어주면 된다. 일반적으로 &lt;code class=&quot;language-text&quot;&gt;applyMiddelware()&lt;/code&gt;를 사용해 &lt;code class=&quot;language-text&quot;&gt;redux-thunk&lt;/code&gt;를 사용할 수 있겠다.&lt;/p&gt;
&lt;h3 id=&quot;component에-적용&quot;&gt;&lt;a href=&quot;#component%EC%97%90-%EC%A0%81%EC%9A%A9&quot; aria-label=&quot;component에 적용 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Component에 적용&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import React from &amp;#39;react&amp;#39;;
import { connect } from &amp;#39;react-redux&amp;#39;;

const SongDetail = ({ song }) =&amp;gt; {
  if(!song) {
    return &amp;lt;div&amp;gt;Select a song&amp;lt;/div&amp;gt;
  }

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;h3&amp;gt;Details for:&amp;lt;/h3&amp;gt;
      &amp;lt;p&amp;gt;
        Title: { song.title }
        &amp;lt;br /&amp;gt;
        Duration: { song.duration }
      &amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

const mapStateToProps = state =&amp;gt; {
  return { song: state.selectedSong }
};

export default connect(mapStateToProps)(SongDetail);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드로 Component에 적용한 모습을 확인할 수 있다. 먼저 &lt;code class=&quot;language-text&quot;&gt;connect()()&lt;/code&gt; 함수의 역할과 구조가 굉장히 중요하다고 생각한다. 사용하는 문법은 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function connect(mapStateToProps?, mapDispatchToProps?, mergeProps?, options?)(component?)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 커링을 통해 connect 내부에서는 외부함수에서 4가지 parameter를 넘겨주고 내부 함수에 component를 받아 앞의 4가지 인자를 component로 전달해 주는 역할을 한다. 4개의 인자는 모두 optional이며, 아래와 같은 컨벤션을 갖는다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;mapStateToProps?: Function&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;mapDispatchToProps?: Function | Object&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;mergeProps?: Function&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;options?: Object&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;mapstatetoprops&quot;&gt;&lt;a href=&quot;#mapstatetoprops&quot; aria-label=&quot;mapstatetoprops permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;mapStateToProps&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;문법&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;mapStateToProps?: (state, ownProps?) =&amp;gt; Object&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;// state: Object
// ownProps?: Object&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;먼저 state는 store에서 받은 state를 의미하고 ownProps는 상위 컴포넌트에서 받은 props를 의미한다. 이를 하나의 props로 전달한다. 아래 사용 예시를 확인하면 이해가 쉽다.

- state를 store에서만 받을 때&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;const mapStateToProps = state =&gt; ({ todos: state.todos });&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- state를 store와 상위 컴포넌트에서 props로 받을 때&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;const mapStateToProps = (state, ownProps) =&gt; ({
todo: state.todos[ownProps.id]
});&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;이런 식으로 조합해서 사용할 수 있다.

#### mapDispatchToProps

이 함수는 특정 이벤트나 어떤 상황에 따라 state를 바꿔주기 위한 함수이다.
자세히 확인하자면, 먼저 문법은 아래와 같다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mapDispatchToProps?: Object | (dispatch, ownProps?) =&gt; Object
// dispatch: Function
// ownProps?: Object&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;이 또한 mapStateToProps 처럼 두개의 인자를 받는다. 첫 번째는 store에서 전달 받는 dispatch, 두 번째는 ownProps이다. 일반적으로 dispatch의 인자로 action 함수를 호출해 type과 새로운 state로 전달할 값을 넣어준다. 이를 기억하고 상황에 따라 connect에 전달 방법을 확인해보자.

1. 아무것도 전달하지 않았을 때&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;// do not pass &lt;code class=&quot;language-text&quot;&gt;mapDispatchToProps&lt;/code&gt;
connect()(MyComponent)
connect(mapState)(MyComponent)
connect(
mapState,
null,
mergeProps,
options
)(MyComponent)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;단순히 null을 전달하면 default 값으로 dispatch를 전달 받는다. 그러면 아래와 같이 컴포넌트 내에서 dispatch를 사용해 직접 type과 payload를 전달하는 방법이 있다.

[React Redux 예시](https://react-redux.js.org/6.x/using-react-redux/connect-mapdispatch#connect-dispatching-actions-with-mapdispatchtoprops)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;function Counter({ count, dispatch }) {
return (
&lt;div&gt;
&amp;#x3C;button onClick={() =&gt; dispatch({ type: ‘DECREMENT’ })}&gt;-&lt;/button&gt;
&lt;span&gt;{count}&lt;/span&gt;
&amp;#x3C;button onClick={() =&gt; dispatch({ type: ‘INCREMENT’ })}&gt;+&lt;/button&gt;
&amp;#x3C;button onClick={() =&gt; dispatch({ type: ‘RESET’ })}&gt;reset&lt;/button&gt;
&lt;/div&gt;
)
}&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;2. connect의 두 번째 인자에 mapDispatchToProps를 전달
일반적으로 action함수를 선언하고 이를 dispatch와 함께 사용한다고 앞서 언급한 바 있다. action 함수와 함께 사용하기 위해서는 mapDispatchToProps에서 dispatch를 받아 action과 결합해야 한다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;const mapDispatchToProps = dispatch =&gt; {
return {
// dispatching plain actions
increment: () =&gt; dispatch({ type: ‘INCREMENT’ }),
decrement: () =&gt; dispatch({ type: ‘DECREMENT’ }),
reset: () =&gt; dispatch({ type: ‘RESET’ })
}
}&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;이러면 component에서 직접 props.increment, props.decrement로 접근 할 수 있으며 이를 사용해서 상태를 변경하도록 설정할 수 있다.
만약 ownProps도 인자로 받는다면 아래와 같이 설정할 수 있다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;// binds on component re-rendering
&amp;#x3C;button onClick={() =&gt; this.props.toggleTodo(this.props.todoId)} /&gt;&lt;/p&gt;
&lt;p&gt;// binds on &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt; change
const mapDispatchToProps = (dispatch, ownProps) =&gt; {
toggleTodo: () =&gt; dispatch(toggleTodo(ownProps.todoId))
}&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;코드를 간단히 분석해 보자면, ownProps로 상위 컴포넌트에서 todo ID값을 받아 todo 상태를 변경하는 `toggleTodo` action 함수에 전달해 dispatch에 다시 전달하여 todo 상태를 변경하는 것이라고 볼 수 있겠다.

3. action과 dispatch를 합쳐주는 `bindActionCreators`

위와 같이 일일히 설정해주기가 힘들고, 어차피 action 함수의 함수명을 그대로 사용할 것이라면, bindActionCreators API로 간단하게 mapDispatchToProps를 대체할 수 있다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;import { bindActionCreators } from ‘redux’&lt;/p&gt;
&lt;p&gt;const increment = () =&gt; ({ type: ‘INCREMENT’ })
const decrement = () =&gt; ({ type: ‘DECREMENT’ })
const reset = () =&gt; ({ type: ‘RESET’ })&lt;/p&gt;
&lt;p&gt;// binding an action creator
// returns (…args) =&gt; dispatch(increment(…args))
const boundIncrement = bindActionCreators(increment, dispatch);&lt;/p&gt;
&lt;p&gt;// binding an object full of action creators
const boundActionCreators = bindActionCreators(
{ increment, decrement, reset },
dispatch
);
// returns
// {
//   increment: (…args) =&gt; dispatch(increment(…args)),
//   decrement: (…args) =&gt; dispatch(decrement(…args)),
//   reset: (…args) =&gt; dispatch(reset(…args)),
// }&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;action이 하나라면 `bindActionCreators` 함수의 인자로 action 함수를 직접 넣으면 되지만, 만약 action 함수가 2개 이상이라면 반드시 객체의 property로 전달해야한다. (`{ increment, decrement, reset }`) 
이렇게 전달하면 가장 마지막에서 볼 수 있 듯 dispatch를 binding하여 객체로 return해준다.

#### mergeProps
세 번째 parameter로 최종 props를 어떻게 정희할 것인지에 대한 부분이다.
만약 아무것도 넣지 않는다면 default로 `{ ...ownProps, ...stateProps, ...dispatchProps }`와 같이 정의한다.
사용 문법은 아래와 같다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mergeProps?: (stateProps, dispatchProps, ownProps) =&gt; Object&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;connect 함수를 설명하면서 굉장히 길어졌지만, connect 함수의 설명과 함께 컴포넌트에서 어떻게 사용하는지에 대한 설명이 같이 진행 되었기 때문에 추가적인 컴포넌트 사용설명은 생략하겠다.

이 외에 Middle Ware 사용법이나 Hooks에 적용하는 방법은 추가 포스팅으로 설명하도록 하겠다. 앞서 언급했지만, 아직 React-Redux를 Propject에 적용하면서 다방면으로 사용해 본 것이 아니기에, 잘못된 정보나 오류를 포함한 내용이 있을 수 있다. 앞으로 학습하면서 이를 수정해 나가도록 하겠다.

___

&amp;gt; 공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.

---&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[이차원 배열 알고리즘]]></title><description><![CDATA[최근 진행한 면접에서 라이브 코딩을 진행했던 알고리즘 문제에 대해서 정리해보고자 한다. 알고리즘 초심자로써 틈틈히 공부를 해야겠다는 깨달음을 얻고 왔다.]]></description><link>https://ssangq.netlify.com//posts/algorithm-two-dimensional-array-1</link><guid isPermaLink="false">https://ssangq.netlify.com//posts/algorithm-two-dimensional-array-1</guid><pubDate>Sun, 17 Nov 2019 12:23:22 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;TL;DR&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;최근 좋은 기회가 닿아 면접을 보게 되었다. 사실 면접 준비를 하면서 기술 질문이나 프로젝트 관련해서 질문을 할 것으로 예상했고 코딩테스트 또한 내가 풀어봤던 알고리즘 이거나 간단한 UI를 만드는 문제가 나올 줄 예상했지만, 역시나 면접은 예상하기 힘든 방향으로 흘러갔다.&lt;/p&gt;
&lt;p&gt;사실 문제를 받자마자 벙졌다는 표현이 맞을 것 같다. 내가 한 번도 풀어보지 못한 방식의 2차원 배열의 요소를 특정 규칙으로 출력하는 내용이였다. 약 30분의 시간을 주셨고 중간에 힌트도 주셨지만 내 근심과 걱정으로 &lt;strong&gt;&lt;em&gt;그득&lt;/em&gt;&lt;/strong&gt; 한 표정과 함께 주신 힌트마저 잘못 판단하여 결국 풀지 못하고 처참한 결과를 내었다.&lt;/p&gt;
&lt;p&gt;하지만, 면접 이후 결과가 어떻든 다시 와서 풀어보며 굉장히 간단한 코드에 한 번 놀랐고, 이런 방면으로 생각을 넓힐 수 있었던 것에 좋은 경험과 가르침을 얻고 왔다고 생각한다.&lt;/p&gt;
&lt;p&gt;문제는 이중배열의 왼쪽부터 대각선 모양으로 출력하는 방식이였다.
예를 들자면,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;[
[1, 2, 3]
[4, 5, 6]
[7, 8, 9]
]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같은 2차원 배열의 내부 배열 길이는 모두 같고, [1, 4, 2, 7, 5, 3, 8, 6, 9] 순서로 출력하는 것이다.&lt;/p&gt;
&lt;p&gt;알고리즘의 초반 설계와 규칙등을 노트에 그려보며 약 1시간 정도 걸려서 문제를 풀 수 있었고, 내가 푼 코드는 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const diagonalPrint = m =&amp;gt; {
  const xLen = m[0].length;
  const yLen = m.length;
  const totalCount = yLen + xLen;

  const result = [];

  for(let i = 0; i &amp;lt; totalCount; i++) {
    for(let j = 0; j &amp;lt;= i; j++) {
      const y = i - j;
      const x = j;

      if(y &amp;lt; yLen &amp;amp;&amp;amp; x &amp;lt; xLen) result.push(m[y][x]);
    }
  };

  return result;
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;처음에 굉장히 갈팡질팡 했던 부분이 반복문의 기준 횟수를 어떻게 둬야 하는가 하는 점이었다. 두 번째 어려웠던 부분은 이차원 배열의 문제를 안풀어 봤던 탓에 값에 접근해야 할 방향을 잡지 못했던 것이었다. 테스트 도중 좌표 형식으로 접근해 보라는 힌트를 주셨지만, 당시에는 감이 오지 않았다.&lt;/p&gt;
&lt;p&gt;면접 이후 혼자 풀어볼때는 처음 접근을 저 두부분에 집중해서 진행했다. 총 반복 횟수를 구하기 위해서 여러 시행착오를 겪으며 대각선 방향으로 선을 그어서 그 부분을 추가 반복문으로 접근하면 된다고 생각하여 for문 안에 for문을 돌리자고 생각했다. 이후, 대각선 한 개당 한 번의 반복을 진행하면 된다고 생각했고 이는 총 배열의 길이와 2차 배열 (내부 배열)의 길이를 더하면 나온다는 규칙을 발견했다.&lt;/p&gt;
&lt;p&gt;그리고 추가 반복문인 J를 대각선의 요소가 가장 많았다가 점점 작아질 경우 어떻게 처리할 것인지에 대해 많이 고민했지만, i와 j로 가능한 모든 좌표를 찍을 수 있다고 가정했을 때 좌표의 x, y가 총 배열과 2차 배열의 총 길이보다 크면 안된다는 규칙을 발견해서 이를 적용 시켰다.  &lt;/p&gt;
&lt;p&gt;나에겐 굉장히 어려운 문제였지만, 어떤 면에서는 굉장히 쉽게 풀 수 있는 문제라고 생각하고 무엇보다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;수학은 익숙해지는 것이다 - 폰노이만&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 말처럼 알고리즘을 많이 접해보고 생각해보는 것이 이러한 테스트에 대한 명확한 해결책이라고 생각한다. 다시 이런 황당함을 되풀이 하지 않기 위해 많이 풀어봐야겠다.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</content:encoded></item><item><title><![CDATA[Router Api 뜯어보기]]></title><description><![CDATA[React Router를 학습하기 위해 React Router를 Customizing한 블로그를 뒤져가며 나도 같이 만들어보며 원리를 이해하고자 학습하고 이렇게 정리하고자 한다.]]></description><link>https://ssangq.netlify.com//posts/custom-react-router</link><guid isPermaLink="false">https://ssangq.netlify.com//posts/custom-react-router</guid><pubDate>Tue, 22 Oct 2019 11:38:22 GMT</pubDate><content:encoded>&lt;p&gt;React Router를 학습하기 위해 React Router를 Customizing한 블로그를 뒤져가며 나도 같이 만들어보며 원리를 이해하고자 학습하고 이렇게 정리하고자 한다.&lt;/p&gt;
&lt;h2 id=&quot;react-router&quot;&gt;&lt;a href=&quot;#react-router&quot; aria-label=&quot;react router permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;React Router&lt;/h2&gt;
&lt;p&gt;React Router Dom Library를 사용하면서 React Router가 어떤식으로 동작하는지 궁금했다. 함께 공부하는 분이 이전에 학습하고 만들어봤던 custom router를 참고해서 일단 따라 만들어보며 이해하려고 노력했다. 사실 React Router와 완전히 같지는 않지만 사용이 상당히 비슷하기 때문에 몇몇 Api를 제외하고는 내부 동작 또한 비슷할 것으로 생각된다. 차근 차근 정리해보려한다.&lt;/p&gt;
&lt;h3 id=&quot;필요한-libraries&quot;&gt;&lt;a href=&quot;#%ED%95%84%EC%9A%94%ED%95%9C-libraries&quot; aria-label=&quot;필요한 libraries permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;필요한 libraries&lt;/h3&gt;
&lt;p&gt;먼저 Custom Router를 만들기 위해서는 &lt;a href=&quot;https://www.npmjs.com/package/history&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;history&lt;/a&gt;, &lt;a href=&quot;https://www.npmjs.com/package/querystringify&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;querystringify&lt;/a&gt; libraries가 필요하다. &lt;strong&gt;history&lt;/strong&gt; library는 브라우저의 history 즉, 페이지 이동의 정보를 관리하는 library이고, &lt;strong&gt;querystringify&lt;/strong&gt;는 말 그대로 URL의 query string을 파싱해주는 작업을 도와준다.&lt;/p&gt;
&lt;h3 id=&quot;router를-만들기에-앞서&quot;&gt;&lt;a href=&quot;#router%EB%A5%BC-%EB%A7%8C%EB%93%A4%EA%B8%B0%EC%97%90-%EC%95%9E%EC%84%9C&quot; aria-label=&quot;router를 만들기에 앞서 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Router를 만들기에 앞서&lt;/h3&gt;
&lt;p&gt;일단 현재 경로와 같은 Routing 정보는 전역에서 접근이 가능해야 Link와 Route가 제 기능을 다 할 수 있을 것이다. 이를 위해 여기서는 Context Api를 사용해 routing 정보를 전역에서 접근할 수 있게 한다.&lt;/p&gt;
&lt;h3 id=&quot;custom-router&quot;&gt;&lt;a href=&quot;#custom-router&quot; aria-label=&quot;custom router permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Custom Router&lt;/h3&gt;
&lt;h4 id=&quot;1-location-정보-분석을-도와주는-함수&quot;&gt;&lt;a href=&quot;#1-location-%EC%A0%95%EB%B3%B4-%EB%B6%84%EC%84%9D%EC%9D%84-%EB%8F%84%EC%99%80%EC%A3%BC%EB%8A%94-%ED%95%A8%EC%88%98&quot; aria-label=&quot;1 location 정보 분석을 도와주는 함수 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. Location 정보 분석을 도와주는 함수&lt;/h4&gt;
&lt;p&gt;현재 브라우저 Location (URL 내부의) 정보를 쪼개는 util 함수를 먼저 만든다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import qs from &amp;#39;querystringify&amp;#39;;

export function locationToRoute(location) {
  // location comes from the history package
  return {
    path: location.pathname,
    hash: location.hash,
    query: qs.parse(location.search),
  };
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;인자로 location 정보를 받으면, location의 프로퍼티인 pathname, hash, search 정보를 추후 사용하기 쉽게 객체로 저장하도록 한다.&lt;/p&gt;
&lt;h4 id=&quot;2-router-context&quot;&gt;&lt;a href=&quot;#2-router-context&quot; aria-label=&quot;2 router context permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. Router Context&lt;/h4&gt;
&lt;p&gt;이제 Router 정보를 전역에서 접근할 수 있도록 Context Api를 사용해 만든다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import React from &amp;quot;react&amp;quot;;
import { createBrowserHistory } from &amp;quot;history&amp;quot;;
import { locationToRoute } from &amp;quot;./utils&amp;quot;;

export const history = createBrowserHistory();

export const RouterContext = React.createContext({
  route: locationToRoute(history.location),
});&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;먼저 history library에서 createBrowserHistory Api를 사용해 새로운 browser history를 만든다. 그리고 새로운 Context를 만드는데, &lt;strong&gt;route&lt;/strong&gt; 프로퍼티에 현재 location을 저장하는 객체를 Context 초기값으로 설정해준다. &lt;strong&gt;route&lt;/strong&gt; 프로퍼티의 값은 util 함수로 만들었던 &lt;code class=&quot;language-text&quot;&gt;locationToRoute&lt;/code&gt;에 history.location을 인자로 넣어 결과 값을 저장한다.
이제 useContext로 context를 불러 현재 path, hash, query 값에 접근할 수 있다.&lt;/p&gt;
&lt;h4 id=&quot;3-route와-link-component&quot;&gt;&lt;a href=&quot;#3-route%EC%99%80-link-component&quot; aria-label=&quot;3 route와 link component permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. Route와 Link Component&lt;/h4&gt;
&lt;p&gt;React Route의 주 기능을 담당하는 &lt;code class=&quot;language-text&quot;&gt;Route&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;Link&lt;/code&gt; 컴포넌트를 만들 차례다. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Route&lt;/code&gt; 컴포넌트는 url에 제공되는 path가 일치할 경우 컴포넌트를 띄우는 작업을 수행한다.
&lt;code class=&quot;language-text&quot;&gt;Link&lt;/code&gt; 컴포넌트는 전체 페이지를 Re-loading하지 않고 &lt;code class=&quot;language-text&quot;&gt;history&lt;/code&gt; api를 통해 URL의 path를 바꿔주는 작업을 수행한다.&lt;/p&gt;
&lt;p&gt;이렇게 Link가 전체 페이지의 Re-loading 없이 path를 바꿔주고, Route 컴포넌트에서는 path에 따라 해당하는 컴포넌트만 render해주는 작업으로 이뤄진다.
그러면 useContext를 사용해 위에서 만든 Context의 데이터를 사용해 &lt;code class=&quot;language-text&quot;&gt;Route&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;Link&lt;/code&gt; 컴포넌트를 만들어보자.&lt;/p&gt;
&lt;h5 id=&quot;router&quot;&gt;&lt;a href=&quot;#router&quot; aria-label=&quot;router permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Router&lt;/h5&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import React from &amp;quot;react&amp;quot;;
import { RouterContext } from &amp;quot;./context&amp;quot;;

export function Route({ path, children }) {
  // Extract route from RouterContext
  const { route } = React.useContext(RouterContext);

  // Return null if the supplied path doesn&amp;#39;t match the current route path
  if (route.path !== path) {
    return null;
  }

  return children;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Router 컴포넌트는 2개의 props를 받는데, &lt;code class=&quot;language-text&quot;&gt;path와&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt;이다. &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt;은 &lt;code class=&quot;language-text&quot;&gt;Route&lt;/code&gt;의 자식요소로 전달된 컴포넌트를 그대로 가져와서 렌더링 하기위함이고, &lt;code class=&quot;language-text&quot;&gt;path&lt;/code&gt;는 위에서 보다시피 Context로 가져온 route 정보에서 현재 path와 비교 후 인자로 들어온 path와 Context에 있는 path가 일치하지 않으면 새로운 뷰 (children이 갖고 있는)를 출력해준다.&lt;/p&gt;
&lt;h5 id=&quot;link&quot;&gt;&lt;a href=&quot;#link&quot; aria-label=&quot;link permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Link&lt;/h5&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import React from &amp;quot;react&amp;quot;;
import { RouterContext, history } from &amp;quot;./context&amp;quot;;

export function Link(props) {
  const { to, onClick, children } = props;

  // Extract route from RouterContext
  const { route } = React.useContext(RouterContext);
  const handleClick = (e) =&amp;gt; {
    e.preventDefault();

    // Dont&amp;#39; navigate if current path
    if (route.path === to) {
      return;
    }

    // Trigger onClick prop manually
    if (onClick) {
      onClick(e);
    }

    // Use history API to navigate page
    history.push(to)
  };

  return (
    &amp;lt;a {...props} onClick={handleClick}&amp;gt;
      {children}
    &amp;lt;/a&amp;gt;
  );
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Link는 &lt;code class=&quot;language-text&quot;&gt;to&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;onClick&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt; props를 받는다. &lt;code class=&quot;language-text&quot;&gt;to&lt;/code&gt;는 URL을 변경할 path를 의미한다. 현재 Link 컴포넌트를 클릭하면 Context에 저장된 현재 &lt;code class=&quot;language-text&quot;&gt;path(route.path)&lt;/code&gt;와 비교해서 같지 않으면 인자로 받은 to를 &lt;code class=&quot;language-text&quot;&gt;history.push(to)&lt;/code&gt;와 같은 방법으로 history에 추가해 줌으로써 현재 path를 바꿔 Route에 알려주는 역할을 한다. 인자로 받은 onClick은 단순히 onClick 함수가 있다면 해당 event 객체를 전달하기 위함이고, children은 변경 없이 Link 기능만 갖도록 하여 출력하도록 return한다.&lt;/p&gt;
&lt;p&gt;여기서 중요한 것은 &lt;code class=&quot;language-text&quot;&gt;a&lt;/code&gt; tag의 사용이라고 생각한다. 일반적으로 서버사이드 렌더링에서는 HTML에서 &lt;code class=&quot;language-text&quot;&gt;a&lt;/code&gt; Tag를 사용해 페이지 전환을 하는데, SPA에서도 마찬가지로 &lt;code class=&quot;language-text&quot;&gt;a&lt;/code&gt; Tag를 사용해 이 작업을 진행하고 있었다. 또한 page 전체 Re-loading을 막기 위해 &lt;code class=&quot;language-text&quot;&gt;e.preventDefault()&lt;/code&gt;를 사용했다는 점까지, 생각보다 상당히 간단하게 구현이 가능하구나 라는 느낌을 받았다.&lt;/p&gt;
&lt;h3 id=&quot;4-router-component&quot;&gt;&lt;a href=&quot;#4-router-component&quot; aria-label=&quot;4 router component permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. Router Component&lt;/h3&gt;
&lt;p&gt;이렇게 각 컴포넌트에서 Context를 데이터를 사용하고 변경할 수 있으려면 &lt;code class=&quot;language-text&quot;&gt;Provider&lt;/code&gt; 컴포넌트가 필요하다. 이와 함께 추가적인 기능을 수행하는 &lt;code class=&quot;language-text&quot;&gt;Router&lt;/code&gt; 컴포넌트를 알아보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import React from &amp;quot;react&amp;quot;;
import { locationToRoute } from &amp;quot;./utils&amp;quot;;
import { history, RouterContext } from &amp;quot;./context&amp;quot;;
import { Route } from &amp;quot;./route&amp;quot;;
import { Link } from &amp;quot;./link&amp;quot;;

class Router extends React.Component {
  constructor(props) {
    super(props);

    // Convert our routes into an array for easy 404 checking
    this.routes = Object.keys(props.routes).map((key) =&amp;gt; props.routes[key].path);

    // Listen for path changes from the history API
    this.unlisten = history.listen(this.handleRouteChange);

    // Define the initial RouterContext value
    this.state = {
      route: locationToRoute(history.location),
    };
  }

  componentWillUnmount() {
    // Stop listening for changes if the Router component unmounts
    this.unlisten();
  }
  
  handleRouteChange = (location) =&amp;gt; {
    const route = locationToRoute(location);
    this.setState({ route: route });
  }

  render() {
    // Define our variables
    const { children, NotFound } = this.props;
    const { route } = this.state;

    // Create our RouterContext value
    const routerContextValue = { route };

    // Check if 404 if no route matched
    const is404 = this.routes.indexOf(route.path) === -1;

    return (
      &amp;lt;RouterContext.Provider value={routerContextValue}&amp;gt;
        {is404 ? &amp;lt;NotFound/&amp;gt; : children}
      &amp;lt;/RouterContext.Provider&amp;gt;
    );
  }
}

export { history, RouterContext, Router, Route, Link }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Router는 먼저 2개의 props를 받는데, &lt;code class=&quot;language-text&quot;&gt;routes list&lt;/code&gt;와 404 에러처리에 대한 &lt;code class=&quot;language-text&quot;&gt;NotFound&lt;/code&gt; 컴포넌트이다. 이 두 props는 &lt;code class=&quot;language-text&quot;&gt;routes list&lt;/code&gt;로 등록할 path를 모두 확인해 해당 경로가 없을 경우 바로 &lt;code class=&quot;language-text&quot;&gt;NotFound&lt;/code&gt; 컴포넌트를 출력해주기 위함이다.&lt;/p&gt;
&lt;p&gt;또한 RouterContext를 통해 route 값을 각 컴포넌트에 전달하는 역할도 하고있고, &lt;code class=&quot;language-text&quot;&gt;history.listen&lt;/code&gt;을 통해 현재 history의 변경을 route값으로 저장하고 있다. 마지막으로는 export로 모든 컴포넌트를 한번에 export하는 모습을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;react-router-dom&lt;/code&gt;을 열어보니 Context Propvider 역할을 Switch에서 하고 있으며, &lt;code class=&quot;language-text&quot;&gt;history&lt;/code&gt;를 BrowserRouter에서 생성해 Router 컴포넌트로 전달하고 있었다.&lt;/p&gt;
&lt;p&gt;아래는 이 Costom Router를 사용한 코드이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;export const routes = {
  home: {
    path: &amp;quot;/&amp;quot;,
  },
  about: {
    path: &amp;quot;/about&amp;quot;
  },
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import React from &amp;quot;react&amp;quot;;
import ReactDOM from &amp;quot;react-dom&amp;quot;;
import {Router, Link, Route, history} from &amp;quot;./router&amp;quot;;
import {routes} from &amp;quot;./routes&amp;quot;;

function NotFound() {
  return (
    &amp;lt;div&amp;gt;
      &amp;lt;p&amp;gt;404 - Not Found&amp;lt;/p&amp;gt;
      &amp;lt;Link to={routes.home.path}&amp;gt;Back to home&amp;lt;/Link&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}

function App() {
  return (
    &amp;lt;Router routes={routes} NotFound={NotFound}&amp;gt;
      &amp;lt;Route path={routes.home.path}&amp;gt;
        &amp;lt;p&amp;gt;Home&amp;lt;/p&amp;gt;
        &amp;lt;Link to={routes.about.path}&amp;gt;Go to about&amp;lt;/Link&amp;gt;
        &amp;lt;Link to=&amp;quot;/unknown&amp;quot;&amp;gt;Go to unknown route&amp;lt;/Link&amp;gt;
        &amp;lt;div className=&amp;quot;link&amp;quot; onClick={() =&amp;gt; history.push(routes.about.path)}&amp;gt;
          Programmatically go to about
        &amp;lt;/div&amp;gt;
      &amp;lt;/Route&amp;gt;
      &amp;lt;Route path={routes.about.path}&amp;gt;
        &amp;lt;p&amp;gt;About&amp;lt;/p&amp;gt;
        &amp;lt;Link to={routes.home.path}&amp;gt;Go to home&amp;lt;/Link&amp;gt;
      &amp;lt;/Route&amp;gt;
    &amp;lt;/Router&amp;gt;
  );
}

const rootElement = document.getElementById(&amp;quot;root&amp;quot;);
ReactDOM.render(&amp;lt;App /&amp;gt;, rootElement);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</content:encoded></item><item><title><![CDATA[자료구조 - Sort]]></title><description><![CDATA[Data Structure와 알고리즘을 공부하면서 Sort와 그 알고리즘에 대해 학습한 내용을 정리하고자한다.]]></description><link>https://ssangq.netlify.com//posts/data-structure-sorting</link><guid isPermaLink="false">https://ssangq.netlify.com//posts/data-structure-sorting</guid><pubDate>Tue, 08 Oct 2019 12:44:22 GMT</pubDate><content:encoded>&lt;p&gt;React의 Memoization, Tree 구조 등, 공부를 하면 할 수록 Data Structure에 대한 용어와 개념을 접하면서 공부의 필요성을 더욱 체감하게 됐다. 절대적으로 공부벌레는 아니지만, 개발을 하면서 사용하는 기술의 원리나 효율적인 사용 방법에 대해 계속 관심이 가게 되다보니 자연스럽게 자료구조 공부의 필요성을 느끼게 되었다. (하지만 생각보다 열심히 하지 않는게 함정…)  &lt;/p&gt;
&lt;p&gt;일단 몇 가지 중요하다고 여겨지는 정렬에 대해 정리하고자한다.&lt;/p&gt;
&lt;h2 id=&quot;sort-정렬&quot;&gt;&lt;a href=&quot;#sort-%EC%A0%95%EB%A0%AC&quot; aria-label=&quot;sort 정렬 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Sort (정렬)&lt;/h2&gt;
&lt;p&gt;정렬은 &lt;em&gt;컴퓨터에서 데이터를 빠르게 찾아낼 수 있는 방법&lt;/em&gt;으로 굉장히 중요한 주제 중 하나이다. 정렬된 배열이 당연히 정렬되지 않은 배열보다 검색이 빠를 수 밖에 없다. 이러한 개념을 바탕으로 속도와 공간면에서 장단점을 갖고 있는 다양한 정렬 방식이 있다.&lt;/p&gt;
&lt;h2 id=&quot;quicksort-빠른-정렬&quot;&gt;&lt;a href=&quot;#quicksort-%EB%B9%A0%EB%A5%B8-%EC%A0%95%EB%A0%AC&quot; aria-label=&quot;quicksort 빠른 정렬 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Quicksort (빠른 정렬)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Quicksort&lt;/strong&gt;란 기준점을 기준으로 배열을 나누고 한 쪽에는 기준점보다 큰 항목들이, 다른 쪽에는 작은 항목을 위치시키면서 모든 항목이 정렬될 때까지 이 과정을 반복한다. 가장 이상적인 기준점은 배열의 중간 값이겠지만, 현실적으로 정렬되지 않는 배열의 중간 값을 구하기 위해서는 추가적인 비용이 들기 때문에 첫 번째 항목과 중간 항목, 마지막 항목의 중간 값을 취해 기준점을 얻는 방식으로 진행한다고 한다.&lt;br&gt;
아래 예를 확인해 보자.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/37759759/66368185-3a2de100-e9d2-11e9-937c-e4137c48684a.png&quot; alt=&quot;011019_1052_QuickSortAl2&quot;&gt;&lt;/p&gt;
&lt;p&gt;위의 사진 처럼, 5, 6, 9의 중간 값은 6이기 때문에 6을 기준점으로 잡고, 양쪽 끝에서부터 하나씩 중간 값으로 전진하며 비교한다. 5는 6보다 작기 때문에 다음 3으로 넘어가고, 3도 작기 때문에 7로, 7은 6보다 크기 때문에 이제 오른쪽에서 비교를 시작한다. 6과 9를 비교하고 9가 크기 때문에 다음 2로 넘어가고 2는 6보다 작기 때문에 앞서 왼쪽에서 6보다 컸던 7과 Switch 한다. 그리고 나서 중간 값 6을 기준으로 양쪽 데이터를 둘로 나눠 다시 기준점을 잡고 정렬을 하는 방식이다.&lt;/p&gt;
&lt;p&gt;알고리즘은 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const partition = (array, left, right) =&amp;gt; {
  const pivot = array[Math.floor((right + left) / 2)];

  while(left &amp;lt;= right) {
    while(pivot &amp;gt; array[left] ) {
      left++;
    }

    while(pivot &amp;lt; array[right]) {
      right--;
    }

    if(left &amp;lt;= right) {
      const temp = array[left];
      array[left] = array[right];
      array[right] = temp;
      left++;
      right--;
    }
  }
  return left;
}

const quickSortHelper(items, left, right) {
  let idx;
  if(items.length &amp;gt; 1) {
    idx = partition(items, left, right);

    if(left &amp;lt; idx - 1) {
      quickSortHelper(items, left, idx - 1);
    }

    if(idx &amp;lt; right) {
      quickSortHelper(item, idx, right);
    }
  }
  return items;
}

const quickSort = () =&amp;gt; {
  return quickSortHelper(items, 0, items.length-1)
}

quickSort([6, 1, 23, 4, 2, 3]);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;도움받은-블로그&quot;&gt;&lt;a href=&quot;#%EB%8F%84%EC%9B%80%EB%B0%9B%EC%9D%80-%EB%B8%94%EB%A1%9C%EA%B7%B8&quot; aria-label=&quot;도움받은 블로그 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;도움받은 블로그&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://ui.toast.com/weekly-pick/ko_20190731/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;TOAST UI&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://kentcdodds.com/blog/usememo-and-usecallback&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Kent C. Dodds&lt;/a&gt;  &lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</content:encoded></item><item><title><![CDATA[React 최적화, useMemo, useCallback, React.memo]]></title><description><![CDATA[React Todo Web Application을 만들면서 시도해봤던 최적화 중 useMemo와 useCallback, 그리고 그와 비슷한 React.memo에 대한 정리를 하고자한다.]]></description><link>https://ssangq.netlify.com//posts/react-memo-useMemo-useCallback</link><guid isPermaLink="false">https://ssangq.netlify.com//posts/react-memo-useMemo-useCallback</guid><pubDate>Thu, 03 Oct 2019 21:12:22 GMT</pubDate><content:encoded>&lt;p&gt;React 최적화를 공부하면서 &lt;code class=&quot;language-text&quot;&gt;useMemo, useCallback, React.memo&lt;/code&gt;를 접했다. &lt;code class=&quot;language-text&quot;&gt;useMemo&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;useCallback&lt;/code&gt;은 실제로 Todo Application에 적용해 봤지만, 일단 최적화 시도를 위한 API 사용을 해본 것일 뿐 정확하게 어떻게 최적화가 되는지에 대해서는 알지 못했다. 이번 기회에 &lt;code class=&quot;language-text&quot;&gt;useMemo&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;useCallback, React.mem&lt;/code&gt;o가 어떻게 최적화가 되는지 학습하여 정리하려고 한다.&lt;/p&gt;
&lt;h2 id=&quot;최적화에-사용되는-memoization&quot;&gt;&lt;a href=&quot;#%EC%B5%9C%EC%A0%81%ED%99%94%EC%97%90-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-memoization&quot; aria-label=&quot;최적화에 사용되는 memoization permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;최적화에 사용되는 Memoization&lt;/h2&gt;
&lt;p&gt;Memoization이란 &lt;code class=&quot;language-text&quot;&gt;이전 값을 메모리에 저장해 동일한 계산의 반복을 제거해 빠른 처리를 가능하게 하는 기술&lt;/code&gt; 이라고 한다. useMemo, useCallback, React.memo는 모두 이 &lt;code class=&quot;language-text&quot;&gt;Memoization&lt;/code&gt;을 기반으로 작동한다. 그럼 이 &lt;code class=&quot;language-text&quot;&gt;Memoization&lt;/code&gt;이 어떻게 사용되는지 확인해보자.&lt;/p&gt;
&lt;h2 id=&quot;reactmemo&quot;&gt;&lt;a href=&quot;#reactmemo&quot; aria-label=&quot;reactmemo permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;React.memo&lt;/h2&gt;
&lt;h3 id=&quot;reactmemo의-특징과-사용&quot;&gt;&lt;a href=&quot;#reactmemo%EC%9D%98-%ED%8A%B9%EC%A7%95%EA%B3%BC-%EC%82%AC%EC%9A%A9&quot; aria-label=&quot;reactmemo의 특징과 사용 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;React.memo의 특징과 사용&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const Welcome = ({ name }) =&amp;gt; {
  return &amp;lt;h1&amp;gt;Hello { name }&amp;lt;/h1&amp;gt;;
};

export default React.memo(Welcome);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;React.memo는 일반적으로 위와 같이 사용되며 직접 함수를 감싸서 사용하기도 한다. React.memo는 Welcome의 결과를 Memoization해서 이후 props가 변경될때까지 현재 memoized된 내용을 그대로 사용하여 리렌더링을 막는다. 이렇게 Memoized된 내용을 재사용하여 렌더링시 가상 DOM에서 달라진 부분을 확인하지 않아 성능상의 이점이 생기게 된다.&lt;/p&gt;
&lt;p&gt;React.memo가 props나 props의 객체를 비교할 때 얕은 비교를 진행하는데, 얕은 비교란 원시 값의 경우는 같은 값을 갖는지 확인하고 객체나 배열과 같은 참조 값은 같은 주소 값을 갖고 있는지 확인한다.&lt;/p&gt;
&lt;p&gt;React.memo 메서드는 &lt;code class=&quot;language-text&quot;&gt;React.memo(component, compFunc)&lt;/code&gt;와 같은 형태가 기본 형태인데, &lt;code class=&quot;language-text&quot;&gt;compFunc&lt;/code&gt; 부분에는 내가 수동으로 비교방식을 수정할 수 있다. 하지만 사용해보지는 않았다.&lt;/p&gt;
&lt;h3 id=&quot;reactmemo를-언제-써야-할까&quot;&gt;&lt;a href=&quot;#reactmemo%EB%A5%BC-%EC%96%B8%EC%A0%9C-%EC%8D%A8%EC%95%BC-%ED%95%A0%EA%B9%8C&quot; aria-label=&quot;reactmemo를 언제 써야 할까 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;React.memo를 언제 써야 할까?&lt;/h3&gt;
&lt;p&gt;이러한 React 최적화 방식들을 공부하면서 접했던 내용은 React.memo의 내부 동작 원리보다는 무조건 적인 사용을 지양하라는 것이었다. 그 이유는 최적화를 위한 연산이 불필요한 경우엔 비용만 발생시키기 때문이다. React.memo는 다음과 같은 상황에서 사용을 권장한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Pure Functional Component에서&lt;/li&gt;
&lt;li&gt;Rendering이 자주일어날 경우&lt;/li&gt;
&lt;li&gt;re-rendering이 되는 동안에도 계속 같은 props값이 전달될 경우&lt;/li&gt;
&lt;li&gt;UI element의 양이 많은 컴포넌트의 경우&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;일반적으로 불필요한 Render가 많이 발생하는 곳에서 사용하라는 말과 같다. 개인적으로 Todo Web application을 진행하면서 부모 컴포넌트가 자주 rendering될 때마다 자식 컴포넌트가 쓸데없이 함께 렌더링 되는 경우를 겪은 적이 있는데, 이 때 React.memo를 사용해 rendering을 막은 것을 React dev tool로 확인했던 것이 기억에 남는다.&lt;/p&gt;
&lt;h3 id=&quot;reactmemo를-사용하지-말아야-할-경우는&quot;&gt;&lt;a href=&quot;#reactmemo%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%90%EC%95%84%EC%95%BC-%ED%95%A0-%EA%B2%BD%EC%9A%B0%EB%8A%94&quot; aria-label=&quot;reactmemo를 사용하지 말아야 할 경우는 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;React.memo를 사용하지 말아야 할 경우는?&lt;/h3&gt;
&lt;p&gt;위의 경우를 제외하면 사용하지 않는 것을 권장하지만, 일반적으로 class 기반의 컴포넌트를 래핑하는 것도 적절하지 않은 사용으로 설명된다. 이 경우 memoization을 해야겠다면, PureComponent를 확장하여 사용하거나 &lt;code class=&quot;language-text&quot;&gt;shouldComponentUpdate()&lt;/code&gt;를 사용하길 권장하고있다.&lt;/p&gt;
&lt;h3 id=&quot;reactmemo의-주의-사항---부모가-전달하는-callback-함수&quot;&gt;&lt;a href=&quot;#reactmemo%EC%9D%98-%EC%A3%BC%EC%9D%98-%EC%82%AC%ED%95%AD---%EB%B6%80%EB%AA%A8%EA%B0%80-%EC%A0%84%EB%8B%AC%ED%95%98%EB%8A%94-callback-%ED%95%A8%EC%88%98&quot; aria-label=&quot;reactmemo의 주의 사항   부모가 전달하는 callback 함수 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;React.memo의 주의 사항 - 부모가 전달하는 callback 함수&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function MyApp({ store, cookies }) {
  return (
    &amp;lt;div className=&amp;quot;main&amp;quot;&amp;gt;
      &amp;lt;header&amp;gt;
        &amp;lt;MemoizedLogout
          username={store.username}
          onLogout={() =&amp;gt; cookies.clear()}
        /&amp;gt;
      &amp;lt;/header&amp;gt;
      {store.content}
    &amp;lt;/div&amp;gt;
  );
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같은 MyApp component의 경우 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;MemoizedLogout /&amp;gt;&lt;/code&gt;컴포넌트는 onLogout과 username이란 두개의 props를 전달받게 된다. MemoizedLogout이 React.memo로 래핑된 함수 컴포넌트라고 할 때, MyApp이 re-rendering 되더라도 MemoizedLogout에 전달되는 props값이 동일하다면 MemoizedLogout component는 re-rendering을 피할 수 있을까? 정답은 아니라고 한다.&lt;/p&gt;
&lt;p&gt;onLogout의 callback 함수는 MyApp이 re-rendring이 될 때마다 새로운 참조값을 갖게 될 것이다. 함수의 내용은 같더라도 주소 값이 다르다면 MemoizedLogout은 re-rendering이 발생할 것이고, React.memo는 오히려 쓸데없는 메모리만 낭비하는 것이다.
이를 위해 useCallback을 통해 callback 함수를 동일한 callback 인스턴스로 설정한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const MemoizedLogout = React.memo(Logout);

function MyApp({ store, cookies }) {
  const onLogout = useCallback(() =&amp;gt; {
    cookies.clear();
  }, []);
// ...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;항상 같은 함수 인스턴스를 반환하기 때문에 MemoizedLogout의 React.memo가 정상 기능을 수행한다.&lt;/p&gt;
&lt;h2 id=&quot;usememo--usecallback&quot;&gt;&lt;a href=&quot;#usememo--usecallback&quot; aria-label=&quot;usememo  usecallback permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;useMemo &amp;#x26; useCallback&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;useMemo&lt;/strong&gt;는? 사용방법을 제외하고는 React.memo와 매우 흡사하다. React.memo가 component의 결과 값을 memoized하여 불필요한 re-rendering을 관리한다면, useMemo는 함수의 결과 값을 memoized하여 불필요한 연산을 관리한다. 아래 코드를 보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const memoizedValue = useMemo(() =&amp;gt; computeExpensiveValue(a, b), [a, b]);
const memoizedValue = useCallback(computeExpensiveValue(a, b), [a, b]); // 위와 동일&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;useMemo의 특징은 일단 함수 호출 이후의 return 값이 memoized되며, 두 번째 파라미터의 배열 내부 값이 변경될 때마다 첫 번째 파라미터의 callback 함수를 실행시키는 구조다. useCallback을 사용해도 useMemo의 대체형태로 사용 할 수 있다고 하는데, useCallback은 아래에서 정리하겠다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;useCallback&lt;/strong&gt;은 useMemo와 흡사하지만, 일반적으로 함수를 memoized하며, 아래와 같이 사용된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const handleChange = useCallback(e =&amp;gt; {
    setNum(e.target.value);
  }, []);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;useCallback을 통해 memoized된 함수는 예를 들어 event handler로 사용되며, 마찬가지로 2번째 인자가 변경될 때마다 함수가 다시 memoized된다.&lt;/p&gt;
&lt;h3 id=&quot;usecallback의-예시&quot;&gt;&lt;a href=&quot;#usecallback%EC%9D%98-%EC%98%88%EC%8B%9C&quot; aria-label=&quot;usecallback의 예시 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;useCallback의 예시&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;useCallback 사용 전&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function CountButton({ onClick, count }) {
  return &amp;lt;button onClick={onClick}&amp;gt;{count}&amp;lt;/button&amp;gt;;
}
function DualCounter() {
  const [count1, setCount1] = React.useState(0);
  const increment1 = () =&amp;gt; setCount1(c =&amp;gt; c + 1);
  const [count2, setCount2] = React.useState(0);
  const increment2 = () =&amp;gt; setCount2(c =&amp;gt; c + 1);
  return (
    &amp;lt;&amp;gt;
      &amp;lt;CountButton count={count1} onClick={increment1} /&amp;gt;
      &amp;lt;CountButton count={count2} onClick={increment2} /&amp;gt;
    &amp;lt;/&amp;gt;
  );
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;useCallback 사용 후&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const CountButton = React.memo(function CountButton({ onClick, count }) {
  return &amp;lt;button onClick={onClick}&amp;gt;{count}&amp;lt;/button&amp;gt;;
});
function DualCounter() {
  const [count1, setCount1] = React.useState(0);
  const increment1 = React.useCallback(() =&amp;gt; setCount1(c =&amp;gt; c + 1), []);
  const [count2, setCount2] = React.useState(0);
  const increment2 = React.useCallback(() =&amp;gt; setCount2(c =&amp;gt; c + 1), []);
  return (
    &amp;lt;&amp;gt;
      &amp;lt;CountButton count={count1} onClick={increment1} /&amp;gt; // React.memo로 래핑되었다는 가정
      &amp;lt;CountButton count={count2} onClick={increment2} /&amp;gt; // React.memo로 래핑되었다는 가정
    &amp;lt;/&amp;gt;
  );
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;useCallback을 사용하여 count1이나 count2 둘 중 하나의 state만 변경되었음에도 2개의 CountButton이 re-rendering되는 것을 막아 최적화를 이뤘다.&lt;/p&gt;
&lt;h2 id=&quot;최적화에-대한-생각&quot;&gt;&lt;a href=&quot;#%EC%B5%9C%EC%A0%81%ED%99%94%EC%97%90-%EB%8C%80%ED%95%9C-%EC%83%9D%EA%B0%81&quot; aria-label=&quot;최적화에 대한 생각 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;최적화에 대한 생각&lt;/h2&gt;
&lt;p&gt;실제로 React Dev Tools를 통해 불필요한 re-rendering을 막는 것을 보니 굉장히 유용한 API라는 생각과 함께 적극적으로 사용해야겠다고 생각한다. 하지만, 아직 React에 대한 숙련도가 높지 않은 만큼 높은 레벨의 기술일 수록 더욱 신중하고 조심히 써야한다고 생각한다. 위에 정리했던 대로 최적화를 위한 코드가 잘못 사용되면 부담을 가중시키는 코드로 변질될 수 있으니, 앞으로 원리를 더 이해하고 경험을 쌓아가며 좋은 코드를 작성하기 위한 고민을 해야겠다.&lt;/p&gt;
&lt;h2 id=&quot;도움받은-블로그&quot;&gt;&lt;a href=&quot;#%EB%8F%84%EC%9B%80%EB%B0%9B%EC%9D%80-%EB%B8%94%EB%A1%9C%EA%B7%B8&quot; aria-label=&quot;도움받은 블로그 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;도움받은 블로그&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://ui.toast.com/weekly-pick/ko_20190731/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;TOAST UI&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://kentcdodds.com/blog/usememo-and-usecallback&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Kent C. Dodds&lt;/a&gt;  &lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</content:encoded></item><item><title><![CDATA[React, Class 기반과 Hoooks의 Lifecycle]]></title><description><![CDATA[React로 프로젝트를 끝낸 시점에, 아직도 Class와 Hooks의 Lifecycle과 그 관리에 사용되는 메서드에 대해 명확하게 알지 못한다. 다시 한 번 정리하면서 Lifecycle이 어떻게 이뤄지고 그 순서가 어떻게 되는지에 대해 공부하고자 한다.]]></description><link>https://ssangq.netlify.com//posts/react-lifecycle</link><guid isPermaLink="false">https://ssangq.netlify.com//posts/react-lifecycle</guid><pubDate>Sun, 22 Sep 2019 16:12:22 GMT</pubDate><content:encoded>&lt;p&gt;리액트를 공부하면서, 웹을 막 접했던 시절 진입장벽이 거의 만리장성 수준이라고 느끼게 해준 용어가 바로 Lifecycle 이었다. 물론 React 의 구조나 작동에 대해 이해도하지 못한채 Lifecycle 이란 벽을 만나 끝내 오르지 못하고 다음을 기약했지만, 이제는 그 벽을 조금은 오를 수 있는 준비가 되었다. 하나씩 정리하면서 부족한 부분을 조금 더 채우고자 한다.&lt;/p&gt;
&lt;h2 id=&quot;class-based-react&quot;&gt;&lt;a href=&quot;#class-based-react&quot; aria-label=&quot;class based react permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Class based React.&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/37759759/65383863-16be3180-dd56-11e9-9771-46a40ba34569.png&quot; alt=&quot;React-Lifecycle2&quot;&gt;&lt;/p&gt;
&lt;p&gt;위의 그림과 같이 모든 Component 는 크게 &lt;code class=&quot;language-text&quot;&gt;Mounting(생성) - Updating(업데이트) - Unmounting(제거)&lt;/code&gt; 단계를 거친다고 한다. 각가의 단계에서는 또 세분한 cycle 이 존재하는데, 이를 하나씩 짚어보면&lt;/p&gt;
&lt;h3 id=&quot;mounting-componentwillmount-까지의-단계는-생략---deprecated&quot;&gt;&lt;a href=&quot;#mounting-componentwillmount-%EA%B9%8C%EC%A7%80%EC%9D%98-%EB%8B%A8%EA%B3%84%EB%8A%94-%EC%83%9D%EB%9E%B5---deprecated&quot; aria-label=&quot;mounting componentwillmount 까지의 단계는 생략   deprecated permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Mounting (componentWillMount 까지의 단계는 생략 - deprecated)&lt;/h3&gt;
&lt;p&gt;처음 &lt;code class=&quot;language-text&quot;&gt;Mounting&lt;/code&gt;된 시점에서 &lt;code class=&quot;language-text&quot;&gt;render()&lt;/code&gt;를 통해 컴포넌트가 DOM 에 붙게 된다. &lt;code class=&quot;language-text&quot;&gt;render()&lt;/code&gt; 함수는 &lt;code class=&quot;language-text&quot;&gt;Pure functions&lt;/code&gt;이기 때문에 어떤 사이드 작업이 이뤄져선 안되며, &lt;code class=&quot;language-text&quot;&gt;setState()&lt;/code&gt;와 같은 state 변경 작업을 render 함수 안에서 해서는 안된다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;render()&lt;/code&gt;함수가 실행되면 &lt;code class=&quot;language-text&quot;&gt;componentDidMount()&lt;/code&gt;가 실행되며 &lt;code class=&quot;language-text&quot;&gt;Mouting&lt;/code&gt; 작업이 종료되는데, &lt;code class=&quot;language-text&quot;&gt;componentDidMount()&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;setstate()&lt;/code&gt;의 사용이 가능하며 dom 에 부착과 동시에 실행되기 때문에 state 변경작업이 이뤄질 경우 rendering 이 다시 일어나지만 UI 의 변화가 사용자에게 보이진 않는다. &lt;strong&gt;다시 말하자면, render 가 두 번 일어나지만 화면에는 한 번의 출력만 나타난다는 것이다.&lt;/strong&gt; 하지만 rendering 작업이 두 번 이뤄지면 성능상의 문제가 나타나기 때문에, 일반적으로 특별한 케이스인 API 호출이나 component 의 render 작업에 영향이 없어 re-rendring 이 이뤄지지 않는 작업에 사용이 권장된다고 한다.&lt;/p&gt;
&lt;p&gt;일반적으로 state 가 변경되는 작업을 할 경우엔 애초에 &lt;code class=&quot;language-text&quot;&gt;constructor&lt;/code&gt;에 선언하는 것이 권장된다고 한다.&lt;/p&gt;
&lt;h3 id=&quot;updating&quot;&gt;&lt;a href=&quot;#updating&quot; aria-label=&quot;updating permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Updating&lt;/h3&gt;
&lt;p&gt;Props 나 state 의 변화는 &lt;code class=&quot;language-text&quot;&gt;Updating&lt;/code&gt; 작업을 발생시킨다. &lt;code class=&quot;language-text&quot;&gt;updating&lt;/code&gt; 주기에서의 &lt;code class=&quot;language-text&quot;&gt;render()&lt;/code&gt; 작업이 발생하기 직전 &lt;code class=&quot;language-text&quot;&gt;shouldComponentUpdate()&lt;/code&gt;가 실행된다. &lt;code class=&quot;language-text&quot;&gt;shouldComponentUpdate()&lt;/code&gt;또한 특별한 상황에서만 주로 사용되는데, 그 상황이 바로 &lt;strong&gt;불필요한 render 작업의 취소&lt;/strong&gt;이다. redner 를 하기 전이기 때문에 불필요한 render 를 사전에 막을 수 있고 &lt;code class=&quot;language-text&quot;&gt;return false&lt;/code&gt;를 통해 취소할 수 있다. 그렇기 때문에 &lt;code class=&quot;language-text&quot;&gt;shouldComponentUpdate()&lt;/code&gt; 내부에서 state 를 변경하는 일을 해선 안된다고 한다.&lt;/p&gt;
&lt;p&gt;이후 &lt;code class=&quot;language-text&quot;&gt;render()&lt;/code&gt;가 실행되 업데이트 작업이 완료되면 마지막으로 &lt;code class=&quot;language-text&quot;&gt;componentDidUpdate()&lt;/code&gt;가 실행된다. 이 작업에서는 &lt;code class=&quot;language-text&quot;&gt;setState()&lt;/code&gt;를 사용해 state 를 변경할 수 있지만, 부적절한 사용은 무한 루프를 야기하기 때문에 필요한 경우에 사용해야한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;shouldComponentUpdate()&lt;/code&gt;는 첫번째 인자로 바뀔 state 를 받지만, &lt;code class=&quot;language-text&quot;&gt;componentDidUpdate()&lt;/code&gt;는 첫번째 인자로 바뀌기 전 state 를 받고 있다. 이는 서로 호출 단계가 render 이전과 이후이기 때문이다.&lt;/p&gt;
&lt;h3 id=&quot;unmounting&quot;&gt;&lt;a href=&quot;#unmounting&quot; aria-label=&quot;unmounting permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Unmounting&lt;/h3&gt;
&lt;p&gt;component 제거에서 사용되는 메서드는 &lt;code class=&quot;language-text&quot;&gt;componenetWillUnmount()&lt;/code&gt;이다. 일반적으로 연결했던 이벤트 리스너를 제거하거나 clear timers or caches, cancelling API 등의 정리 활동을 한다고 한다. 아직 사용해보지는 않았다.&lt;/p&gt;
&lt;h2 id=&quot;react-hooks&quot;&gt;&lt;a href=&quot;#react-hooks&quot; aria-label=&quot;react hooks permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;React Hooks&lt;/h2&gt;
&lt;p&gt;기존 &lt;code class=&quot;language-text&quot;&gt;Functional Component&lt;/code&gt;에서는 Lifecylcle API 를 사용할 수 없었지만, Hook 이 추가되면서 그 일이 가능하게 되었다. Hooks 를 사용한 뒤 class component 의 Lifecycle 을 보고 느꼈지만, &lt;code class=&quot;language-text&quot;&gt;componentDidMount()&lt;/code&gt;처럼 (비록 componentDidMount 는 1 회성이지만) &lt;code class=&quot;language-text&quot;&gt;render()&lt;/code&gt;실행 뒤에 state 의 변경을 감지하여 어떤 작업이 이뤄지는 그런 lifecycle 작업이 없어 이상하다는 생각을 했었다. Hooks API 인 &lt;code class=&quot;language-text&quot;&gt;useEffect()&lt;/code&gt;는 그 부분을 채워주었다.&lt;/p&gt;
&lt;h3 id=&quot;useeffect&quot;&gt;&lt;a href=&quot;#useeffect&quot; aria-label=&quot;useeffect permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;useEffect&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;useEffect(()=&amp;gt;{funcs},[state])&lt;/code&gt;는 paint 작업까지 완료된 DOM update 이후 callback 함수안에 실행할 함수를 기억했다가 state 변경시마다 기억하는 함수를 호출하는 방식으로 작동한다. useEffect 는 Browser 의 작업을 방해하지 않는 방식으로 이뤄졌기 때문에 훨씬 부드럽게 작동하는 느낌을 받을 수 있다고 한다. 아직까지 크게 느낀적은 없지만…&lt;/p&gt;
&lt;p&gt;useEffect 의 두번째인자 &lt;code class=&quot;language-text&quot;&gt;[state]&lt;/code&gt; 부분에는 &lt;code class=&quot;language-text&quot;&gt;복수의 state =&amp;gt; [state1, state2..]&lt;/code&gt;를 쓸수도 있고 아무것도 안쓸 수도 있고 state 없이 &lt;code class=&quot;language-text&quot;&gt;[]&lt;/code&gt;만 쓸 수도 있다. 아무것도 안 쓸 경우엔 모든 render 이후 내부에 작성한 함수가 실행되지만, &lt;code class=&quot;language-text&quot;&gt;[]&lt;/code&gt; 빈 배열만 넣은 경우엔 최초 render 이후 한 번만 실행된다고 한다. (&lt;code class=&quot;language-text&quot;&gt;componentDidMount()&lt;/code&gt;와 비슷) 복수의 state 를 넣은 경우엔 기존과 같이 해당 state 변경시마다 render 이후 함수가 호출된다.&lt;/p&gt;
&lt;h3 id=&quot;useeffect-with-cleanup&quot;&gt;&lt;a href=&quot;#useeffect-with-cleanup&quot; aria-label=&quot;useeffect with cleanup permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;useEffect with Cleanup&lt;/h3&gt;
&lt;p&gt;class component 의 설명에서 clean up 기능을 했던 &lt;code class=&quot;language-text&quot;&gt;componenetWillUnmount()&lt;/code&gt;와 비슷하게 unmount 시 작동하는 방식이 있다. 바로 useEffect 내부 콜백함수에 &lt;code class=&quot;language-text&quot;&gt;return () =&amp;gt; {funcs}&lt;/code&gt;처럼 제거할 함수를 쓴 callback 함수를 return 하는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/37759759/65386733-67e01c80-dd7a-11e9-83a8-90f16eb16515.JPG&quot; alt=&quot;Hooks-cleanup&quot;&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/37759759/65386757-7e867380-dd7a-11e9-90c9-4a5a85f83e3d.JPG&quot; alt=&quot;Hooks-cleanup(2)&quot;&gt;
&lt;a href=&quot;https://ko.reactjs.org/docs/hooks-effect.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;출처&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;위의 채팅 관련 서비스에서 subscribe 과 unsubscribe 을 통해 clean-up 으로 커넥션을 지웠다가 다시 생성하는 과정을 useEffect 의 return 을 통해 통해 이루는 것을 볼 수 있다. 언젠가는 쓸 일이 있을 것라고 생각한다.&lt;/p&gt;
&lt;h3 id=&quot;useeffect-의-좋은점&quot;&gt;&lt;a href=&quot;#useeffect-%EC%9D%98-%EC%A2%8B%EC%9D%80%EC%A0%90&quot; aria-label=&quot;useeffect 의 좋은점 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;useEffect 의 좋은점&lt;/h3&gt;
&lt;p&gt;lifecycle 에 대한 learning curve 를 크게 줄여준 것 같다. &lt;code class=&quot;language-text&quot;&gt;componentDidMount()&lt;/code&gt;와 render 이후 state 관리에 따른 re-render 작업을 한번에 해결해주고, 코드의 복잡도나 가독성 면에서도 크게 좋아진 것 같아서 좋다. 사실 clean-up 기능을 사용해본적도 없고 아직은 더 시간이 필요하겠지만, 그럼에도 useEffect 가 state 변경을 감시할 수 있는 효율적인 수단이라고 생각한다.&lt;/p&gt;
&lt;h2 id=&quot;도움받은-블로그&quot;&gt;&lt;a href=&quot;#%EB%8F%84%EC%9B%80%EB%B0%9B%EC%9D%80-%EB%B8%94%EB%A1%9C%EA%B7%B8&quot; aria-label=&quot;도움받은 블로그 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;도움받은 블로그&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://programmingwithmosh.com/javascript/react-lifecycle-methods/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;ProgrammingWithMosh&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://ko.reactjs.org/docs/hooks-effect.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React 공식문서&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</content:encoded></item><item><title><![CDATA[Map과 Set의 차이를 다시 한 번 정리하다.]]></title><description><![CDATA[완전 초창기에 개념 없이 배웠던 Map과 Set을 다시 한 번 복습하려고 한다. Map과 Set을 처음 공부했을 때 도저히 이해가 안갔던 부분이 이제는 조금씩 이해되다보니 다시 문서화하고 싶다는 생각이 들었다.]]></description><link>https://ssangq.netlify.com//posts/map-and-set</link><guid isPermaLink="false">https://ssangq.netlify.com//posts/map-and-set</guid><pubDate>Wed, 18 Sep 2019 14:05:14 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;“왜 Map과 Set을 쓸까? Object와 Array가 있는데.. 도대체 뭐가 효율적인거야?”&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;내가 기억하는 처음 Map과 Set을 이론으로만 공부했을 때의 느낀점이다. 자료구조가 뭔지도 몰랐을 (사실 지금도 너무 몰라서 공부중이지만) 시절에 Map과 Set의 특징만 보면서 ‘이런게 있구나’ 라는 정도만 알고 넘어갔던 ES6의 기능이였다.&lt;/p&gt;
&lt;p&gt;사실 코딩을 하면서 Map과 Set을 사용했던 적은 최근검색 UI를 만들때 중복된 배열의 요소를 없애기 위해 사용해본 적 외엔 제대로 사용해 본 적이 없다. 하지만 공부를 할 수록 ‘활용도가 꽤나 크겠다’라는 생각을 갖게 되어서 이를 문서화 시켜 머릿속에서 잊어버릴 때쯤 상기하자는 마음으로 이렇게 정리하기로 했다. 겸사겸사 면접 연습도 될 것 같다는 1+1의 이점도 있겠다..&lt;/p&gt;
&lt;h2 id=&quot;map&quot;&gt;&lt;a href=&quot;#map&quot; aria-label=&quot;map permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Map&lt;/h2&gt;
&lt;p&gt;Map의 특징을 일단 정리하자면,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Map은 Object와 상당히 유사한 순회 가능한 객체이다.&lt;/li&gt;
&lt;li&gt;[key, value]의 형태로 이뤄져있으며, 선언하거나 추가시 이러한 형태로 값을 넣어주어야한다.&lt;/li&gt;
&lt;li&gt;[key, value] 형태에서 key 부분이 어떠한 타입이어도 상관 없다. Object는 string과 symbol만 가능하다.&lt;/li&gt;
&lt;li&gt;length가 아닌 size로 Map 값의 크기를 알 수 있다.&lt;/li&gt;
&lt;li&gt;여러 메소드가 있는데 &lt;code class=&quot;language-text&quot;&gt;map.get(&amp;#39;a&amp;#39;)&lt;/code&gt;과 같은 방식으로 값을 가져올 수 있으며, 전체 key값이나 value값을 가져오는 방식 또한 메소드로 갖고 있다. &lt;code class=&quot;language-text&quot;&gt;map.keys()&lt;/code&gt; , &lt;code class=&quot;language-text&quot;&gt;map.values()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Map의 요소를 배열로 받을 수 있는 방법으로 &lt;code class=&quot;language-text&quot;&gt;[...Map] // return [[&amp;#39;a&amp;#39;, 1], [&amp;#39;b&amp;#39;, 2]]&lt;/code&gt; 스프레드 연산자를 사용할 수 있으며, &lt;code class=&quot;language-text&quot;&gt;for (let [key, value] of map&lt;/code&gt; 또는 &lt;code class=&quot;language-text&quot;&gt;for (let keyvalue of map)&lt;/code&gt;의 형태로 key값과 value값을 순회하며 접근할 수 있다. (전자는 key와 value를 destructuring으로 각각 접근 할 수 있는 것)&lt;/li&gt;
&lt;li&gt;for in을 사용한 순회방식은 undefined만 리턴한다.&lt;/li&gt;
&lt;li&gt;Object와 마찬가지로 동일한 Key값을 가진 값은 맨 마지막 요소만 값으로 갖는다. &lt;code class=&quot;language-text&quot;&gt;new Map([[&amp;#39;a&amp;#39;, 1], [&amp;#39;a&amp;#39;, 2]]) // return {&amp;quot;a&amp;quot; =&amp;gt; 1}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Object는 key값이 숫자로 된 string인 경우, 그 key값이 숫자인 다른 property와 자동적으로 정렬이 일어나지만, Map은 내가 설정한 순서 그대로를 유지한다.&lt;/li&gt;
&lt;li&gt;배열과 다르게 숫자와 숫자로 된 string이 key값일 경우 엄격하게 검사한다. &lt;code class=&quot;language-text&quot;&gt;Map([1, &amp;#39;b&amp;#39;]) // map.has(&amp;#39;1&amp;#39;) return false&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;사실 객체를 사용한다면 굳이 사용할 일이 많지 않겠구나 라는 생각은 변함이 없지만, Map이 &lt;strong&gt;key값을 사용해 property를 delete하는 경우&lt;/strong&gt;, &lt;strong&gt;key값에 대한 정렬&lt;/strong&gt;, &lt;strong&gt;굉장히 큰 양의 데이터를 저장한 경우&lt;/strong&gt;에서 더 좋은 performance를 낸다고 한다. 앞으로 프로젝트를 진행하면서, 또는 현업에서 일하면서 그 사용 사례나 필요성을 고민해봐야겠다.&lt;/p&gt;
&lt;h2 id=&quot;set&quot;&gt;&lt;a href=&quot;#set&quot; aria-label=&quot;set permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Set&lt;/h2&gt;
&lt;p&gt;Set의 특징을 정리해보자면,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;배열과 유사한 순회 가능한 객체이다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;배열처럼 value로만 이뤄져있지만, 값이 키와 동일하게 설정되어있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;cosnt set = new Set([&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;])
set.keys() // return {&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;}
set.values() //return {&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;값은 중복될 수 없으며, 중복될 경우 가장 앞의 값을 제외하고 삭제된다. &lt;code class=&quot;language-text&quot;&gt;new Set([1, 2, 1]) // return {1, 2}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;배열처럼 &lt;code class=&quot;language-text&quot;&gt;set[1]&lt;/code&gt;이나 &lt;code class=&quot;language-text&quot;&gt;set.value(1) // 메서드 자체가 없음&lt;/code&gt;로 중간 값을 확인할 수 없으며, 전체를 순회하는 방식으로만 사용 가능하다. &lt;/li&gt;
&lt;li&gt;이 또한 size 메소드로 length대신 크기를 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;splice를 사용하지 않고 &lt;code class=&quot;language-text&quot;&gt;delete(value)&lt;/code&gt; 메소드를 사용해 손쉽게 배열의 중간 값을 잘라낼 수 있다. &lt;code class=&quot;language-text&quot;&gt;delete&lt;/code&gt;메소드는 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt; or &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt; 값을 리턴한다.&lt;/li&gt;
&lt;li&gt;배열의 값이 있는지 확인하려는 경우, 배열의 indexOf나 includes를 통해 확인하는 것 보다 &lt;code class=&quot;language-text&quot;&gt;set.has(value)&lt;/code&gt;로 확인하는 것이 더욱 빠르다. 리턴 값은 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt; or &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Set은 확실히 Map보다는 활용도가 높다고 생각했다. 최근 검색 UI를 만들 때, 최근검색 기록에 있는 기존 검색어를 재 입력했을 경우 Set을 사용해 처리한 적이 있다. 이 때, 복잡한 코드 및 알고리즘을 쓰지 않고 단 한 줄만으로 해결해 굉장히 유용했던 적이 있는데, 현업에서도 많이 쓰인다하니 항상 머릿속에 두고 활용할 곳을 찾아봐야겠다.&lt;/p&gt;
&lt;h2 id=&quot;weakmap-weackset&quot;&gt;&lt;a href=&quot;#weakmap-weackset&quot; aria-label=&quot;weakmap weackset permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;WeakMap, WeackSet&lt;/h2&gt;
&lt;p&gt;대부분 사용하지 않거나 활용된 곳을 찾기 힘들다고 한다. 각각 Map과 Set의 기능과 공통된 부분이 많으나 다른 부분을 정리하자면,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Map의 key에 해당하는 값과 Set의 값은 오로지 객체만 받을 수 있다.&lt;/li&gt;
&lt;li&gt;자동적으로 Garbage Collection을 하여 사용하지 않는 참조는 모두 삭제된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const weakSet = new WeakSet([{a: &amp;#39;a&amp;#39;}]);
weakSet // return WeakSet {} : 참조가 없어 Garbage Collection 됨.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;advanced-utilization&quot;&gt;&lt;a href=&quot;#advanced-utilization&quot; aria-label=&quot;advanced utilization permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Advanced Utilization&lt;/h2&gt;
&lt;p&gt;위에 언급하지는 않았지만, Map과 Set 모두 entries라는 메소드로 모든 iterator 객체를 차례대로 순회할 수 있다.
Set을 예로 들자면, &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const set = new Set([&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;]); // return {&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;}
const setEnt = set.entries(); // return SetIterator 
setEnt.next() // {value: [&amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;], done: false}
setEnt.next() // {value: [&amp;quot;b&amp;quot;, &amp;quot;b&amp;quot;], done: false}
setEnt.next() // {value: undefined, done: true}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;모든 객체를 한 번에 순회하는 것이 아닌, 필요한 부분까지 순회하고 끝낼 수 있어 이러한 방식으로 활용도가 있다고 생각한다.&lt;/p&gt;
&lt;p&gt;또는 spread연산자로 배열화하여 배열 메서드를 활용해 Set함수간의 교집합, 차집합 등을 계산 할 수 있어 이러한 방식도 공부해보고 사용하면 좋을 것 같다.&lt;/p&gt;
&lt;h2 id=&quot;도움받은-블로그&quot;&gt;&lt;a href=&quot;#%EB%8F%84%EC%9B%80%EB%B0%9B%EC%9D%80-%EB%B8%94%EB%A1%9C%EA%B7%B8&quot; aria-label=&quot;도움받은 블로그 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;도움받은 블로그&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://codeburst.io/array-vs-set-vs-map-vs-object-real-time-use-cases-in-javascript-es6-47ee3295329b&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;코드버스트&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://medium.com/@hongkevin/js-5-es6-map-set-2a9ebf40f96b&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Kevin Seaokyou Hong&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://medium.com/front-end-weekly/es6-map-vs-object-what-and-when-b80621932373&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Maya shavin&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map#%EC%84%A4%EB%AA%85&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;MDN&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</content:encoded></item><item><title><![CDATA[Axios와 Fetch, 무엇을 사용할까?]]></title><description><![CDATA[React를 하면서 Axios를 한 번 써보기로 했다. 근데 Fetch랑 비슷한 것 같은데....]]></description><link>https://ssangq.netlify.com//posts/axios-and-fetch</link><guid isPermaLink="false">https://ssangq.netlify.com//posts/axios-and-fetch</guid><pubDate>Wed, 28 Aug 2019 22:56:14 GMT</pubDate><content:encoded>&lt;h2 id=&quot;axios가-핫-하다던데&quot;&gt;&lt;a href=&quot;#axios%EA%B0%80-%ED%95%AB-%ED%95%98%EB%8B%A4%EB%8D%98%EB%8D%B0&quot; aria-label=&quot;axios가 핫 하다던데 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Axios가 핫 하다던데&lt;/h2&gt;
&lt;p&gt;Axios를 사용하게 된 계기는 Hot 하다는 말 때문이었다. 내가 언젠가는 GET을 사용해 데이터를 받아오는 것 뿐만 아니라 직접 POST, PUT 메소드를 써가며 데이터를 저장, 변경하는 것 까지 직접 하고싶은 마음에 이러한 메소드 사용이 편리하다는 소식을 접하고 일단 써보자는 마음으로 React기반의 TODO Application의 기본 데이터를 가져올 때 사용해봤다. 하지만 아직까지는 GET 메소드 외에 사용할 일이 없었다…&lt;/p&gt;
&lt;h2 id=&quot;axios의-장점&quot;&gt;&lt;a href=&quot;#axios%EC%9D%98-%EC%9E%A5%EC%A0%90&quot; aria-label=&quot;axios의 장점 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Axios의 장점?&lt;/h2&gt;
&lt;p&gt;Fetch API와 비교한 Axios의 장점을 간단하게 정리하자면 아래와 같다고한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IE까지 대부분의 브라우저를 지원한다. (구형 포함)&lt;/li&gt;
&lt;li&gt;JSON 데이터를 자동 변환해준다. (.json() 사용할 필요 없음)&lt;/li&gt;
&lt;li&gt;Node.js에서도 사용 가능하다. (fetch도 별도 라이브러리로 사용할 수 있는 것으로 알고 있으나 사용해 보지는 않았다.)&lt;/li&gt;
&lt;li&gt;요청을 중도 Cancel, 응답시간 초과 설정 등의 기능이 있다. (개인적으로 꼭 써보고 싶은 기능)&lt;/li&gt;
&lt;li&gt;400, 500대의 Error 발생시에 &lt;code class=&quot;language-text&quot;&gt;reject&lt;/code&gt; 로 response를 전달해 catch로 잡아낼 수 있다. (fetch의 경우 네트워크 장애나 요청이 완료되지 않은 경우에만 &lt;code class=&quot;language-text&quot;&gt;reject&lt;/code&gt;로 response를 전달하기 때문에, 400, 500대의 Error의 경우는 &lt;code class=&quot;language-text&quot;&gt;resolve&lt;/code&gt;로 받아 따로 예외처리를 해야 한다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;느낀점&quot;&gt;&lt;a href=&quot;#%EB%8A%90%EB%82%80%EC%A0%90&quot; aria-label=&quot;느낀점 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;느낀점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;아직까지 큰 프로젝트를 하지 않아서 Fetch보다 좋은 점에 대해 체감하기는 힘들었다. Native로 사용할 수 있는 Fetch와 달리, axios는 설치 및 import를 해야하고, 무거운 느낌도 있기 때문에 사실 체험삼아 사용해 본 것이 아니라면 사용하지 않는 것이 좋았을 것이란 생각이 든다. 하지만, 위의 Axios의 장점들은 서버를 구축하고 큰 프로젝트를 할 수록 분명 편리한 기능이 될 것이라고 생각하기 때문에, 추후 개인 프로젝트를 진행하면 다시 한 번 Axios의 편리하다는 메서드들을 사용하면서 위의 장점들을 살려보고 싶다. (물론 다시 이 글도 업데이트 될 것이라 믿는다..)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;도움받은-곳&quot;&gt;&lt;a href=&quot;#%EB%8F%84%EC%9B%80%EB%B0%9B%EC%9D%80-%EA%B3%B3&quot; aria-label=&quot;도움받은 곳 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;도움받은 곳&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/axios/axios&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Axios Page&lt;/a&gt;  &lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</content:encoded></item><item><title><![CDATA[HTML내부의 <script> 태그 속성인 async와 defer]]></title><description><![CDATA[미션을 하면서 script태그를 body에 써야할지 head에 써야할지 고민하며 review받은 HTML script tag 속성인 async와 defer에 대해 정리해보고자 한다.]]></description><link>https://ssangq.netlify.com//posts/async-and-defer-in-script-tag</link><guid isPermaLink="false">https://ssangq.netlify.com//posts/async-and-defer-in-script-tag</guid><pubDate>Sun, 23 Jun 2019 20:34:14 GMT</pubDate><content:encoded>&lt;p&gt;미션 진행 중 미션에서는 처음 HTML의 코드를 작성하면서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그를 head에 쓸 것인가, body에 쓸것인가를 고민하게 되었다. 물론 대략적으로 &lt;em&gt;body의 마지막에 쓰는 것이 좋다&lt;/em&gt; 라는 주입식 교육으로 인해 계속해서 body의 아랫 부분에 써왔지만, 왜 써야하는지는 수업과 미션을 통해 javascript를 모두 읽은 뒤 html을 렌더링하게되면, 화면 출력을 기다리는 UX 측면에서 부정적인 영향을 주기 때문에 자제해야 한다는 점을 알게 되었다.&lt;/p&gt;
&lt;p&gt;하지만 역시 &lt;strong&gt;정리됨&lt;/strong&gt;, &lt;strong&gt;깔끔함&lt;/strong&gt; 은 코드 작성에서 매우 중요한 특성중 하나라는 점을 느꼈는데, 그 이유는 바로 &lt;code class=&quot;language-text&quot;&gt;async&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;defer&lt;/code&gt;의 사용 때문이다. 단어에서 유추할 수 있 듯, 비동기적 처리를 가능하게 하는 속성이다. 비동기적 처리가 가능하다는 것은 body의 끝 부분에 작성할 필요가 없다는 것이다.&lt;/p&gt;
&lt;p&gt;일반적으로 &lt;code class=&quot;language-text&quot;&gt;async&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;defer&lt;/code&gt;는 모두 외부에서 받아오는 js파일에 한하여 작동한다고 한다.
그렇다면 &lt;code class=&quot;language-text&quot;&gt;async&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;defer&lt;/code&gt;는 정확하게 무엇을 의미하며 어떤 기능을 수행하는 속성일까?&lt;/p&gt;
&lt;h2 id=&quot;async에-대해-알아보자&quot;&gt;&lt;a href=&quot;#async%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90&quot; aria-label=&quot;async에 대해 알아보자 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;async에 대해 알아보자.&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;script async src=&amp;quot;script.js&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;async&lt;/code&gt;는 위와 같이 작성한다. &lt;code class=&quot;language-text&quot;&gt;async&lt;/code&gt; 의 특징은 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;head&amp;gt;&lt;/code&gt;에 삽입하거나 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;body&amp;gt;&lt;/code&gt;에 삽입하여도 parsing작업이 중단되지 않고 script를 비동기적으로 다운로드한다. 하지만, 다운로드 즉시 parsing작업이 중단되고 script가 실행되게 된다.&lt;/p&gt;
&lt;h2 id=&quot;그렇다면-defer는&quot;&gt;&lt;a href=&quot;#%EA%B7%B8%EB%A0%87%EB%8B%A4%EB%A9%B4-defer%EB%8A%94&quot; aria-label=&quot;그렇다면 defer는 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;그렇다면 defer는?&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;script defer src=&amp;quot;script.js&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;defer&lt;/code&gt;는 위와같이 작성하며 &lt;code class=&quot;language-text&quot;&gt;async&lt;/code&gt;와 비슷하게 script 파일을 비동기 다운로드하지만, HTML parsing작업이 끝나기 전까지 스크립트를 실행하지 않는다. 즉, parsing 작업이 모두 이뤄진 후 스크립트가 실행되게 된다.&lt;/p&gt;
&lt;h2 id=&quot;그럼-무조건-defer를-써야하나&quot;&gt;&lt;a href=&quot;#%EA%B7%B8%EB%9F%BC-%EB%AC%B4%EC%A1%B0%EA%B1%B4-defer%EB%A5%BC-%EC%8D%A8%EC%95%BC%ED%95%98%EB%82%98&quot; aria-label=&quot;그럼 무조건 defer를 써야하나 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;그럼 무조건 defer를 써야하나?&lt;/h2&gt;
&lt;p&gt;내 생각으로는 스크립트 코드에 대한 깊은 이해가 없는 경우, 초보자의 경우에는 defer를 사용하면 대부분의 문제는 해결되지 않을까 싶다. 하지만, 각 특징은 아래와 같은 &lt;strong&gt;&lt;em&gt;사용 타이밍(?)&lt;/em&gt;&lt;/strong&gt;을 갖고 있다고 한다.&lt;/p&gt;
&lt;h3 id=&quot;defer를-사용하는-경우&quot;&gt;&lt;a href=&quot;#defer%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0&quot; aria-label=&quot;defer를 사용하는 경우 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;defer를 사용하는 경우&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DOM 조작을 수행하여 HTML과 의존성이 있는 경우. HTML에 완전히 parsing된 이후에 스크립트가 실행되어야 DOM을 완전히 조작할 수 있게된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;async를-사용하는-경우&quot;&gt;&lt;a href=&quot;#async%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0&quot; aria-label=&quot;async를 사용하는 경우 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;async를 사용하는 경우&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DOM 조작을 수행하지도 않으며 HTML과 의존성이 없는 경우.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;굉장히 쉬울 수도 있는 내용이지만, 처음 봤을때는 뭔 차이인지 잘 몰랐기 때문에 다시 한 번 정리할 겸 작성한다.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</content:encoded></item><item><title><![CDATA[서버사이드 렌더링과 클라이언트사이드 렌더링]]></title><description><![CDATA[React를 공부하면서, 또는 Front-end와 약간의 Back-end 내용을 공부하면서 접한 Server Side Rendering, Client Side Rendering에 대한 학습의 필요성을 느껴 정리해보고자 한다.]]></description><link>https://ssangq.netlify.com//posts/rendered-by-server-or-client</link><guid isPermaLink="false">https://ssangq.netlify.com//posts/rendered-by-server-or-client</guid><pubDate>Wed, 19 Jun 2019 21:00:00 GMT</pubDate><content:encoded>&lt;p&gt;React를 공부하기 전이지만, node.js에서 서버 생성이나 그와 관련된 Frame Work을 공부하다보니 그렇게 스쳐지나가며 들었던 &lt;strong&gt;Server Side Rendering&lt;/strong&gt;과 &lt;strong&gt;Client Side Rendering&lt;/strong&gt;의 의미와 특징이 무엇인지 궁금해졌다. 이번 기회에 조금이나마 공부한 것을 정리해보고자 한다. &lt;/p&gt;
&lt;h2 id=&quot;먼저-rendering이란-무엇일까&quot;&gt;&lt;a href=&quot;#%EB%A8%BC%EC%A0%80-rendering%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C&quot; aria-label=&quot;먼저 rendering이란 무엇일까 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;먼저 Rendering이란 무엇일까?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;간단하게 말하면 Rendering은 웹페이지를 화면에 그려주는 것으로 생각하면 된다. 자세한 Rendering에 관한 학습이 필요하다면 아래 링크를 참조하는 것도 좋다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/59361&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;NaverD2 - 브라우저는 어떻게 작동하는가?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;그렇다면-클라이언트와-서버란&quot;&gt;&lt;a href=&quot;#%EA%B7%B8%EB%A0%87%EB%8B%A4%EB%A9%B4-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%99%80-%EC%84%9C%EB%B2%84%EB%9E%80&quot; aria-label=&quot;그렇다면 클라이언트와 서버란 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;그렇다면 클라이언트와 서버란?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;사실 처음에 ‘클라이언트 단, 서버 단에서 렌더링을 하는 방식이야’ 라는 설명을 들었을 때 클라이언트나 서버가 어떤 역할을 하는지도 몰랐기 때문에 도대체 무슨 말인지 알 수가 없었다. (무지했다.. 아직도지만..)&lt;/p&gt;
&lt;p&gt;간단하게 클라이언트와 서버를 설명하자면 요청과 응답의 관계라고 설명할 수 있을 것 같다. 클라이언트는 인터넷을 사용하는 유저 측, 서버는 그 유저가 요청한 정보나 파일을 전달하는 것이라고 생각하면 되겠다.&lt;/p&gt;
&lt;h2 id=&quot;single-page-web-application&quot;&gt;&lt;a href=&quot;#single-page-web-application&quot; aria-label=&quot;single page web application permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Single Page web Application?&lt;/h2&gt;
&lt;p&gt;SPA의 등장 배경은 바로 모바일 기기의 사용때문이라고 한다. PC보다 성능이 낮다보니 웹페이지를 출력하기 위해 기존 방식과는 다른 접근의 필요성이 그 배경이라고 한다.&lt;/p&gt;
&lt;h2 id=&quot;두-방식의-차이점이라-함은&quot;&gt;&lt;a href=&quot;#%EB%91%90-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%B4%EB%9D%BC-%ED%95%A8%EC%9D%80&quot; aria-label=&quot;두 방식의 차이점이라 함은 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;두 방식의 차이점이라 함은?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;두 방식의 차이점은 화면을 렌더링하는 위치, 유저의 요청에 따른 데이터 변화가 화면을 만들어주는 위치라고 한다.&lt;/p&gt;
&lt;h3 id=&quot;웹사이트를-사용하던-중-변화를-주었을-때&quot;&gt;&lt;a href=&quot;#%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8D%98-%EC%A4%91-%EB%B3%80%ED%99%94%EB%A5%BC-%EC%A3%BC%EC%97%88%EC%9D%84-%EB%95%8C&quot; aria-label=&quot;웹사이트를 사용하던 중 변화를 주었을 때 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;웹사이트를 사용하던 중 변화를 주었을 때&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Server Side Rendering&lt;/em&gt;&lt;/strong&gt; 은 서버 단에서 변화된 데이터를 반영해 완성된 화면을 전달해주는 것.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Client Side Rendering&lt;/em&gt;&lt;/strong&gt; 은 변화된 UI를 유저의 브라우저에서 만드는 것&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;초기-view-로딩-속도&quot;&gt;&lt;a href=&quot;#%EC%B4%88%EA%B8%B0-view-%EB%A1%9C%EB%94%A9-%EC%86%8D%EB%8F%84&quot; aria-label=&quot;초기 view 로딩 속도 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;초기 view 로딩 속도&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Server Side Rendering&lt;/em&gt;&lt;/strong&gt; 에서는 view를 서버에서 처리해 초기 로딩속도는 빠르지만, 정보가 많은 B2C 웹 서버에서 등은 서버의 부담이 크다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Client Side Rendering&lt;/em&gt;&lt;/strong&gt; 에서는 CSS, Javascript 파일 등 필요한 파일을 모두 다운로드하기 때문에 view 로딩이 다소 늦지만, 최초 로딩 이후의 요청에 대한 대응이 빠르다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;보안문제&quot;&gt;&lt;a href=&quot;#%EB%B3%B4%EC%95%88%EB%AC%B8%EC%A0%9C&quot; aria-label=&quot;보안문제 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;보안문제&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Server Side Rendering&lt;/em&gt;&lt;/strong&gt; 은 사용자에 대한 정보를 서버측에서 세션으로 관리했다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Client Side Rendering&lt;/em&gt;&lt;/strong&gt; 은 쿠키 이외에 사용자에 대한 정보를 저장할 공간이 마땅치 않다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;요즘-trend는-어떤지&quot;&gt;&lt;a href=&quot;#%EC%9A%94%EC%A6%98-trend%EB%8A%94-%EC%96%B4%EB%96%A4%EC%A7%80&quot; aria-label=&quot;요즘 trend는 어떤지 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;요즘 Trend는 어떤지?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;SPA(Single Page Application)이 성장하면서 전통적인 &lt;strong&gt;&lt;em&gt;Server Side Rendering&lt;/em&gt;&lt;/strong&gt; 방식에서 &lt;strong&gt;&lt;em&gt;Client Side Rendering&lt;/em&gt;&lt;/strong&gt; 으로 변화되고 있는 상황이라고 한다.&lt;/p&gt;
&lt;p&gt;SPA는 APP에 필요한 리소스 모든 정적 리소스를 최초에 한번 다운로드하여 사용하는 Client Side Rendering이라고 한다. 요즘에는 제공되는 정보나 데이터가 굉장히 많아 서버 단에서 렌더링을 하게 된다면 요청시마다 페이지의 새로고침과 더불어 모든 화면을 그리는 작업, 불필요한 트래픽 때문에 성능상의 이슈가 발생한다. 그리하여 렌더링을 유저의 브라우저가 담당하게 하여 필요한 정보만 변경하여 보여주는 클라이언트 단의 렌더링은 유저들에게 더 나은 경험을 제공하기 시작하여 지금의 위치에 오르게됐다고 한다.&lt;/p&gt;
&lt;h2 id=&quot;그럼-react는-client-rendering으로만-이뤄졌다&quot;&gt;&lt;a href=&quot;#%EA%B7%B8%EB%9F%BC-react%EB%8A%94-client-rendering%EC%9C%BC%EB%A1%9C%EB%A7%8C-%EC%9D%B4%EB%A4%84%EC%A1%8C%EB%8B%A4&quot; aria-label=&quot;그럼 react는 client rendering으로만 이뤄졌다 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;그럼 React는 Client Rendering으로만 이뤄졌다?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;일단 대답은 &lt;strong&gt;‘아니오’&lt;/strong&gt; 라고 한다. 추후에 더 공부하여 다루겠지만, Webpack 설정에 따라 Server Side Rendering 또한 제공하고 있다고 한다. 이 부분에 대해서는 더 학습하여 추후 다루기로 하겠다.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</content:encoded></item><item><title><![CDATA[어떻게 인터넷이 연결되는가 (간단 정리)]]></title><description><![CDATA[인터넷이 작동하기 위한 하드웨어 및 네트워크 구조에 대해 매우 기초적인 부분만 간단히 정리하고자 한다.]]></description><link>https://ssangq.netlify.com//posts/how-does-internet-work</link><guid isPermaLink="false">https://ssangq.netlify.com//posts/how-does-internet-work</guid><pubDate>Tue, 21 May 2019 20:24:00 GMT</pubDate><content:encoded>&lt;p&gt;HTTP를 공부하면서 Router 용어를 듣는 순간 기존에 궁금했던 Router의 역할, 허브 또는 스위치의 역할, 이들의 연결관계에 대한 궁금증을 간단하게나마 짚고 넘어가고 싶었다. 함께 공부하는 Jake와 Papico의 설명을 발판으로 삼아 공부한 내용을 정리해보겠다.&lt;/p&gt;
&lt;h2 id=&quot;간단한-작동원리&quot;&gt;&lt;a href=&quot;#%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%9E%91%EB%8F%99%EC%9B%90%EB%A6%AC&quot; aria-label=&quot;간단한 작동원리 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;간단한 작동원리&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 600px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/adbc9d240824930cccdc501431db80b9/3f01f/internet-schema-5.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 93.83333333333333%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAAsSAAALEgHS3X78AAACKElEQVQ4y32TV28CMRCE/f//BxIIJMoTHdF777030XsRkHzg6HIKSfxw2rM9O7Oza/Hxtq7X626345vP51Op1Gq1Op/P+/3+/aZQ/zweD77lcrlUKg0Gg1ar1e/32+12o9HIZDJkVO78ApZntVotl8v1er1ut+vxeI7HYywWY3Oz2fwHRmGlUtlut3BGo1HI0+l0vV6Px+On0wk8Qv6UjdrRaORyucgCLBgMIsHtdiPY5/ORkURq8T+ZG69FhTabDc3g7XZ7JBJpNpuAx+PxL8zqSmQMiclkslqt4N99+WZWkDK43+8EtAfDpAVs3m43NUzGT/DhcJhOp+/kFKzX6xWksubz+Ww2ezJfLhdsrFark8lEoSVYLBZ0C8OHw6HclIvOYQpFYZDggEs0xuv1qoXhkFarNRqNfr9fLadYLOI/k0PzBISdTocDkgUCAVqFpaSTsGQyiW20DansZ7NZBgY+ygQl+CENyQDgbaFQILfFYsEtlJMLeeyHw2GyOxwOThOJBGPDwAj8pAb4qdxsNhsMBo1Gw5OQ9bMIlsslzul0OpKGQiF+4cMmweshPTxIQCevgnTSTKV+TGKfIQHJwDCIuLherwVbHDidTh4d+SibEtTNl+RUy8ChlphRRSYpBG8FKsixBFVchZ8O/cAzrTSVyplcxgYI/n2NJ96QTL5hjKFmpCp4TOF2+7Wg4YLMKOQxlSMePPwEiGTsFDBI7KEdslsYJo8+AfyeCvVMYk6DAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;picture&gt;
        &lt;source
          srcset=&quot;/static/adbc9d240824930cccdc501431db80b9/8ac56/internet-schema-5.webp 240w,
/static/adbc9d240824930cccdc501431db80b9/d3be9/internet-schema-5.webp 480w,
/static/adbc9d240824930cccdc501431db80b9/e88ff/internet-schema-5.webp 600w&quot;
          sizes=&quot;(max-width: 600px) 100vw, 600px&quot;
          type=&quot;image/webp&quot;
        /&gt;
        &lt;source
          srcset=&quot;/static/adbc9d240824930cccdc501431db80b9/e4891/internet-schema-5.png 240w,
/static/adbc9d240824930cccdc501431db80b9/0ce91/internet-schema-5.png 480w,
/static/adbc9d240824930cccdc501431db80b9/3f01f/internet-schema-5.png 600w&quot;
          sizes=&quot;(max-width: 600px) 100vw, 600px&quot;
          type=&quot;image/png&quot;
        /&gt;
        &lt;img
          class=&quot;gatsby-resp-image-image&quot;
          src=&quot;/static/adbc9d240824930cccdc501431db80b9/3f01f/internet-schema-5.png&quot;
          alt=&quot;internet_works&quot;
          title=&quot;internet_works&quot;
          loading=&quot;lazy&quot;
          style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        /&gt;
      &lt;/picture&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;다양한 컴퓨터가 한 곳의 스위치에 연결. (LAN)&lt;/li&gt;
&lt;li&gt;다양한 스위치들이 한 곳의 Router에 연결. (시군구로 비유하자면 switch가 ‘동’, router를 ‘구’에 비유)&lt;/li&gt;
&lt;li&gt;Router들은 다시 서로 다른 Router와 연결 (ISP를 통해 연결되기도 함)&lt;/li&gt;
&lt;li&gt;Router에서 데이터를 전송함에 있어 가장 빠른 경로를 검색하여 데이터 전송.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;용어-정리&quot;&gt;&lt;a href=&quot;#%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC&quot; aria-label=&quot;용어 정리 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;용어 정리&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Router&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;둘 이상의 서로 다른 네트워크를 연결하는 중계 역할.&lt;/li&gt;
&lt;li&gt;데이터에 담긴 주소를 읽고 패킷 전송을 위한 최적 경로 설정.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;공유기&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ISP(인터넷 서비스 업체)에서 제공하는 한 개의 IP 주소로 여러대의 컴퓨터, 노트북, 스마트폰 등이 인터넷을 공유할 수 있게하는 소용량 라우터.&lt;/li&gt;
&lt;li&gt;ISP에서 받은 한 개의 IP주소를 사용해 내부적으로 IP주소를 할당하여 연결된 컴퓨터 및 기타 장치에 부여해주는 기기.&lt;/li&gt;
&lt;li&gt;공유기의 WAN은 통신사의 모뎀과 직접 연결하고 다른 포트에 장비를 연결하여 많은 컴퓨터가 함께 인터넷을 사용.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hub&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;여러대의 컴퓨터를 연결해 네트워크를 만들어주는 장비.&lt;/li&gt;
&lt;li&gt;포트의 갯수는 허브에 따라 다양하고 1개의 포트에 한대의 장비가 할당.&lt;/li&gt;
&lt;li&gt;연결된 컴퓨터 수에 따라 대역이 분리된다.&lt;/li&gt;
&lt;li&gt;허브는 IP주소를 장치에 부여하는 기능이 없어 많은 장치가 인터넷을 공유하기 위해서는 반드시 허브 포트 중 한 곳에 공유기를 연결한 후 다른 포트에 장치를 연결하여 사용.&lt;/li&gt;
&lt;li&gt;공유기 없이 단순 컴퓨터간의 연결 시 A에서 B 컴퓨터로 데이터를 전달하면 모든 컴퓨터로 데이터 전달. (스위치와의 차이점)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스위치&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;한 PC만이 데이터를 전송할 수 있는 허브의 단점을 보완하여 만들어져 다른 PC들이 동시에 통신 가능&lt;/li&gt;
&lt;li&gt;자신에게 연결된 디바이스의 IP와 MAC 주소를 테이블로 갖고 있어 패킷이 전송되면 목적지를 파악하고 빠르게 해당 목적지로 전달함. (허브와의 차이점)&lt;/li&gt;
&lt;li&gt;테이블에 없는 목적지를 가진 패킷이 오면 허브와 같이 모든 장치에 포워딩함.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;참고-사이트&quot;&gt;&lt;a href=&quot;#%EC%B0%B8%EA%B3%A0-%EC%82%AC%EC%9D%B4%ED%8A%B8&quot; aria-label=&quot;참고 사이트 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;참고 사이트&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/Common_questions/How_does_the_Internet_work&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;MDN&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://kkdww.tistory.com/151&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;집사 강가이버&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;http://egloos.zum.com/oxteen/v/5458427&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;이글루스&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://minwan1.github.io/2018/10/01/2018-09-03-network-network-divice/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;완블로그&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</content:encoded></item><item><title><![CDATA[Starting Gatsby with Lumen Theme]]></title><description><![CDATA[Gatsby를 시작하면서 겪었던 어려움 때문에, lumen 테마를 적용했을 때 어떻게 설정을 하는지에 대해 배웠던 점을 정리하고자.. 조금은 도움이 되길.]]></description><link>https://ssangq.netlify.com//posts/starting-gatsby</link><guid isPermaLink="false">https://ssangq.netlify.com//posts/starting-gatsby</guid><pubDate>Wed, 15 May 2019 15:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Gatsby 초보인 나는 더욱 쉽게 시작하기 위해 theme를 사용하길 선택했다… 사실 React 기반이라 처음 시작하기 어렵기도하고 진입장벽이 낮지는 않은 것 같아서..&lt;br&gt;&lt;/p&gt;
&lt;p&gt;그래도 여러가지 이유로 Gatsby를 선택했고, lumen이라는 theme를 선택하고 적용해 보면서 단순히 설정조차도 쉽지는 않았다. 그래서 나중에 참고도 할 겸 이번 페이지에 정리를 해보려 한다.&lt;/p&gt;
&lt;h2 id=&quot;gatsby-설치하기&quot;&gt;&lt;a href=&quot;#gatsby-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0&quot; aria-label=&quot;gatsby 설치하기 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Gatsby 설치하기&lt;/h2&gt;
&lt;p&gt;Googling을 하면 많이 나오지만, 먼저 Gatsby를 설치하는 내용부터 다루겠다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Gatsby 설치하기.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;$ npm i &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;g gatsby&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;cli&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;먼저 위와 같이 작성하여 gatsby를 설치하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Theme 고르기.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;여기 링크된 &lt;a href=&quot;https://www.gatsbyjs.org/starters/?v=2&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Starter&lt;/a&gt;로 들어가면 theme를 선택할 수 있다. (&lt;em&gt;Gatsby Starter&lt;/em&gt;라고 구글에 작성해도 쉽게 찾을 수 있고, 여기서는 lumen만 다루겠다.)&lt;br&gt;&lt;/p&gt;
&lt;p&gt;루멘은 두가지 종류가 있는데 나는 v2라고 쓰여진 것을 선택했다. (더 가볍다고 쓰여있어서..) 찾았으면 깃허브 아이콘을 누르자. 그럼 &lt;a href=&quot;https://github.com/gatsbyjs/gatsby.git&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;여기&lt;/a&gt;와 같은 페이지를 확인할 수 있다. &lt;strong&gt;clone or download&lt;/strong&gt;를 눌러 url을 복사해두자.&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이후 Gatby blog 폴더를 만들 곳에 들어가 comman창에 아래와 같이 입력한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;$ gatsby &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;BLOGNAME&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; https&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;github&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;com&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;GatsbyCentral&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;gatsby&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;v2&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;starter&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;lumen&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;new는 새롭게 만든다는 의미일테고 &lt;/li&gt;
&lt;li&gt;blogname은 컴퓨터에 gatsby blog를 관리할 폴더명&lt;/li&gt;
&lt;li&gt;뒤의 Url은 lumen them의 github clone Url이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;gatsby-설정하기&quot;&gt;&lt;a href=&quot;#gatsby-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0&quot; aria-label=&quot;gatsby 설정하기 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Gatsby 설정하기.&lt;/h2&gt;
&lt;p&gt;Gatsby를 설치하면 먼저 처음 화면은 아래처럼 나올것이다.
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 960px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/de001e14ec18a2035a70d71f8500a173/b1f9d/lumen_starting_page.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 75.04761904761904%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsSAAALEgHS3X78AAABpElEQVQoz3VSWW6DMBTk/qfoEXqMKl+J0iiNgCwsCY5ZbEzAGAwdx03rVumALPB74zczsjdNum1qrLMDrbVSSusRn9+b0zTNv+GNqn97fRGstGXbQSldLleH0M/SKEmSPM/nZ/DGcUyOYS+lu3u73QjJaJ5fr/R6R13XnDM0/yJDXl4UqLVtCw4EQ8GgZ+1onB54MhnM7g4pO9vBeZ2kacPLriJtI0yh6+zpGPZDHoahaZo/qVRVFQR+ksSwHYZBHMdwHgRBGIbwjx6MxOpJKS+XC45w9QhRp2kaRdHpdEoTA9gmhGBF8/l8RhVEMxmHQZJL7mRfVYxzLkTDGBNCYI5+4Nu/CYxSAlMuuR+0Gmw80/w/DNkd+wiM7fd7Ss7F5URJVjFWFAUElmWZ57QqS7yGjO7hDkuzK/KHYcQUxcgpjGEej9mJD4fD8XiEbUP+uVgOGYGhjGwggcM0AmB4DRAEfuX9UnlPzUilWwk1yt10pX15fkrulTK3bRxm3c9a/RvYn397cJZli8VitVwGH5vt+2q73W42m91u5/v+er2Gctv5CSJEYGCUJacfAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;picture&gt;
        &lt;source
          srcset=&quot;/static/de001e14ec18a2035a70d71f8500a173/8ac56/lumen_starting_page.webp 240w,
/static/de001e14ec18a2035a70d71f8500a173/d3be9/lumen_starting_page.webp 480w,
/static/de001e14ec18a2035a70d71f8500a173/e46b2/lumen_starting_page.webp 960w,
/static/de001e14ec18a2035a70d71f8500a173/c139f/lumen_starting_page.webp 1050w&quot;
          sizes=&quot;(max-width: 960px) 100vw, 960px&quot;
          type=&quot;image/webp&quot;
        /&gt;
        &lt;source
          srcset=&quot;/static/de001e14ec18a2035a70d71f8500a173/e4891/lumen_starting_page.png 240w,
/static/de001e14ec18a2035a70d71f8500a173/0ce91/lumen_starting_page.png 480w,
/static/de001e14ec18a2035a70d71f8500a173/b7c40/lumen_starting_page.png 960w,
/static/de001e14ec18a2035a70d71f8500a173/b1f9d/lumen_starting_page.png 1050w&quot;
          sizes=&quot;(max-width: 960px) 100vw, 960px&quot;
          type=&quot;image/png&quot;
        /&gt;
        &lt;img
          class=&quot;gatsby-resp-image-image&quot;
          src=&quot;/static/de001e14ec18a2035a70d71f8500a173/b7c40/lumen_starting_page.png&quot;
          alt=&quot;first_page_lumen&quot;
          title=&quot;first_page_lumen&quot;
          loading=&quot;lazy&quot;
          style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        /&gt;
      &lt;/picture&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;처음에는 아무것도 모르고 성정을 바꾸기 위해 모든 react js 파일들을 뒤져가며 어디에 어떻게 import를 하는지 등의 상관관계를 확인하기 위해 노력했지만, 주변인의 도움으로 간단하게 설정을 할 수 있는 방법을 찾아냈다. 대부분의 설정은 gatsby-config.js파일을 통해 할 수 있다. 먼저 차례대로 알아보자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Profile 바꾸기.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 299px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/d262d0c3ad35a75d956f82797a7cecf1/1edc5/profile.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 92.97658862876254%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABdElEQVQ4y6VUy06DQBTlp/wSV/6DLly4bVx1ZeJr4dboSpO6aGyiq6ZRE2nSTa3WmG5qGRgoA4VSmGmZwTtQ+1gJ9SRcDnAfc88dRklSCCGS4lAWjLLZjPOkSBYZHHPeajy+XB+9NWohpcWC7aH1enP+cLx/ebj71e2wKMxa+TuY85i4rvX+rF4c1M5K3XbLI8OcKiiJ4EFEP5/uy9tbp3s7vY82o1HeynBxkaBe5/akdHVaxtp3fvHnagupNgPlCo1NWZ+zKDxnVVXvKpVmU63X69VqdTAY5BUMnHzPG41G4xS2bUdRtBosUsxv6xmV5B9Q4jjG2Oj3+zpChg6QhhAimWEAAeu6LsYYHEyMTdOEkOWyGWOTFGEY+r4fBOPsTRAElNJJOIFGskdwyJpaViYpNE2ThXUEuT3PkwwhaXXkEOI4DggJPtPpdE2wLDFUAwK5OOzY1MKnBf+1fFUz2NscIVnTMi3D0GHZm/zPmx8Gm50kP0ggSvSoYsh4AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;picture&gt;
        &lt;source
          srcset=&quot;/static/d262d0c3ad35a75d956f82797a7cecf1/8ac56/profile.webp 240w,
/static/d262d0c3ad35a75d956f82797a7cecf1/cf880/profile.webp 299w&quot;
          sizes=&quot;(max-width: 299px) 100vw, 299px&quot;
          type=&quot;image/webp&quot;
        /&gt;
        &lt;source
          srcset=&quot;/static/d262d0c3ad35a75d956f82797a7cecf1/e4891/profile.png 240w,
/static/d262d0c3ad35a75d956f82797a7cecf1/1edc5/profile.png 299w&quot;
          sizes=&quot;(max-width: 299px) 100vw, 299px&quot;
          type=&quot;image/png&quot;
        /&gt;
        &lt;img
          class=&quot;gatsby-resp-image-image&quot;
          src=&quot;/static/d262d0c3ad35a75d956f82797a7cecf1/1edc5/profile.png&quot;
          alt=&quot;profile&quot;
          title=&quot;profile&quot;
          loading=&quot;lazy&quot;
          style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        /&gt;
      &lt;/picture&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;사진&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;먼저 사진은 &lt;code class=&quot;language-text&quot;&gt;src/pages/photo.jpg&lt;/code&gt;를 변경하면 된다. 따로 이름을 변경하면 적용이 안되는 것 같아 파일명은 변경하지 않고 내 프로필 사진으로 교체하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;이름&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;gatsby-config.js 파일 내부의 siteMetadata의 author 객체의 name 값을 변경해주면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;블로그 설명 (이름 하단부)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;gatsby-config.js 파일 내부의 siteMetadata의 subtitle을 변경해주면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Menu 바꾸기.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 244px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/92310073694467f30ebc46a422584566/4d334/menu.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 85.65573770491802%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABXElEQVQ4y7WSzW6CQBSFff8nYFm6QF2ItAZJHIOaoGAwARS7sWA1kvDjQgUhRsHeOEhNqlAXPZmEucOcO8zHKZ2vSpIkjmM8yUo8f6TSoxf5ttSMN202G47jVFXt9brD4VDTNIQQlIZh5DRKzcvlkmEYQRBEUazT9Ggkv5IkU6/3BaHYvN1uwb9YfM3nMEzD+IQKjnUcu/jO0OJ4PMZXYVqXZ/In8/l5pebD4TCbzeBTd7ud7/tRFK1WqzAMXdf1L8oHtiAIgqKoSqUMwGp0DaRPJuUyVa1WSfIlzxwEAZwJzGzbdhwHJp7nhvt9EPjr9dqyrOdC8sSd8fkZatDpdLrN6d2opmbYCmyyFlDidfh/xfEE1JCtwaAPqeSaTdRqsSwLKzzPm6bZaLy3EWqj9n2z53mQZFmWJUkaj8eSKL4xjKIoH9Mp0NJ1HTp3O51/AIbB/LC5IZSt/wb2DcdgyFBEd+O7AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;picture&gt;
        &lt;source
          srcset=&quot;/static/92310073694467f30ebc46a422584566/8ac56/menu.webp 240w,
/static/92310073694467f30ebc46a422584566/d4674/menu.webp 244w&quot;
          sizes=&quot;(max-width: 244px) 100vw, 244px&quot;
          type=&quot;image/webp&quot;
        /&gt;
        &lt;source
          srcset=&quot;/static/92310073694467f30ebc46a422584566/e4891/menu.png 240w,
/static/92310073694467f30ebc46a422584566/4d334/menu.png 244w&quot;
          sizes=&quot;(max-width: 244px) 100vw, 244px&quot;
          type=&quot;image/png&quot;
        /&gt;
        &lt;img
          class=&quot;gatsby-resp-image-image&quot;
          src=&quot;/static/92310073694467f30ebc46a422584566/4d334/menu.png&quot;
          alt=&quot;menu&quot;
          title=&quot;menu&quot;
          loading=&quot;lazy&quot;
          style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        /&gt;
      &lt;/picture&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;menu명&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;gatsby-config.js 파일 내부의 siteMetadata에서 menu 배열 속 해당객체의 label 값을 변경해주면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;menu 추가&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;gatsby-config.js 파일 내부의 siteMetadata에서 객체를 복사 후 이름과 path를 정정해 주면 된다.&lt;/code&gt; 이렇게 한 후 블로그에 게시할 md 파일 안에서 category 값을 menu명과 동일하게 작성하면, 동일한 category의 메뉴만 뜨게된다. (아직 허접이라서 이렇게 참조를 이용한 추가방식 밖에 할 수가 없었다…)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;게시물에 page에 대해&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 557px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/db24c1c35d905f3e2e869ec5b01a53e2/ef2b6/whole_page.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 112.5673249551167%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAIAAACEf/j0AAAACXBIWXMAAA7DAAAOwwHHb6hkAAACS0lEQVQ4y51UiZKiMBDl//9sVjzGgyvcp1wLolwCZl+Ia21NOda4r0JXh9Cd5L1uhHEc+r6fponSiU4DfQfCbrfFkCUpdknikePxmKZpWZaXywXLtxnfBkuSJMuyqqqW7TiuryjK4XDwPK+qKh78audTWWRZ9vuOHCiKIkmSKIriOA7DEAeZL/UsuDxf+34Yhiuecbg7zB9HxHD77c7NlT6OduNjnj9uy52nKYRzdQK6rqNDTYeKTt0bbIvicrvdappqEVXZrTRpJ8uKO0PXdfC33+9N09Q0jW3wJRhsQZ4sS9Mstx3XcTyE4U3OXqVwHMcGi+C/bVt+fjDBbyRwVkGv6zq+58Ux0xkk42ssBYGPEc7wfd9Bbs+zLKuuaxZs6AQTnJBZAt80DANTpIDUUA8WpHAJz1VVFgVeoihnwi5tXTc4Ut9xtByvy+Mv2y19+tn0Evfgrm26tkMx0NtAp5bZn0uF2v78/MQ908AK9L1vKkEQ4nrgGYR5npskaRAE0QzuQKB7sO97hBDDNKET0U1VI+gTCIvvkBENA+Vs2zZNA1IzwRmp1j04TZOyZASeyjJJYrQGEkM8sA3LewU+CIec+bzKqWbBSINNkBI7zAHHMIyODFE8nxyAyNzhZfMoNQEpq/MZ+bju7/1JTi2dbvT/IHT9cL2yHr5NUGtkfzJmfxZMiIaqtG2nyqOuCOo8bIuwbWoUGS835IXTNHXX9V/KTkDHoe8Wi8VqtdJ0fX84rNbr9WYtigtxKW42GwgJu1yKHx+/QP6/P7Y/BjscFDPjmJgAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;picture&gt;
        &lt;source
          srcset=&quot;/static/db24c1c35d905f3e2e869ec5b01a53e2/8ac56/whole_page.webp 240w,
/static/db24c1c35d905f3e2e869ec5b01a53e2/d3be9/whole_page.webp 480w,
/static/db24c1c35d905f3e2e869ec5b01a53e2/9b7c7/whole_page.webp 557w&quot;
          sizes=&quot;(max-width: 557px) 100vw, 557px&quot;
          type=&quot;image/webp&quot;
        /&gt;
        &lt;source
          srcset=&quot;/static/db24c1c35d905f3e2e869ec5b01a53e2/e4891/whole_page.png 240w,
/static/db24c1c35d905f3e2e869ec5b01a53e2/0ce91/whole_page.png 480w,
/static/db24c1c35d905f3e2e869ec5b01a53e2/ef2b6/whole_page.png 557w&quot;
          sizes=&quot;(max-width: 557px) 100vw, 557px&quot;
          type=&quot;image/png&quot;
        /&gt;
        &lt;img
          class=&quot;gatsby-resp-image-image&quot;
          src=&quot;/static/db24c1c35d905f3e2e869ec5b01a53e2/ef2b6/whole_page.png&quot;
          alt=&quot;whole page&quot;
          title=&quot;whole page&quot;
          loading=&quot;lazy&quot;
          style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        /&gt;
      &lt;/picture&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;title: Gatsby
date: &amp;quot;2019-05-15T15:00:00.000Z&amp;quot;
layout: post
draft: false
path: &amp;quot;/posts/starting-gatsby/&amp;quot;
category: &amp;quot;The others&amp;quot;
tags:
- &amp;quot;Gatsby&amp;quot;
- &amp;quot;Web Development&amp;quot;
- &amp;quot;lumen&amp;quot;
- &amp;quot;how to start gatsby with lumen theme&amp;quot;
description: &amp;quot;Gatsby를 시작하면서 겪었던 어려움 때문에, ~~~~&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;일반적으로 md파일의 시작부에 위와 같은 정보를 가져야 인식되도록 설계되어 있다. &lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;title: 게시물의 제목&lt;br&gt;&lt;/li&gt;
&lt;li&gt;date: 날짜. 게시물 가장 상단부의 날짜 표기도 관련&lt;br&gt;&lt;/li&gt;
&lt;li&gt;layout: post로 되어 있어야 게시물로 인식&lt;br&gt;&lt;/li&gt;
&lt;li&gt;draft: 초기값은 false인데 잘 모르겠다.&lt;br&gt;&lt;/li&gt;
&lt;li&gt;path: 글을 클릭했을 때 설정되는 주소(경로)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;category: 게시물의 날짜 옆에 주황색 글씨로 앞서 언급한 대로 폴더의 메뉴로도 활용된다.&lt;br&gt;&lt;/li&gt;
&lt;li&gt;tags: 태그 목록들&lt;br&gt;&lt;/li&gt;
&lt;li&gt;description: 게시물에 보이는 제목 밑의 작은 글씨&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여기까지가 일단 알게된 정보들이고 이정도면 시작하는데 문제는 없을 것이다. 추후 더 알게되는 정보가 있으면 업데이트 하겠다.&lt;/p&gt;
&lt;h2 id=&quot;추가-업데이트-사항&quot;&gt;&lt;a href=&quot;#%EC%B6%94%EA%B0%80-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EC%82%AC%ED%95%AD&quot; aria-label=&quot;추가 업데이트 사항 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;추가 업데이트 사항&lt;/h2&gt;
&lt;p&gt;Netlify를 사용하여 배포할 경우, gatsby 블로그 lumne을 npm으로 깔았다면 Netlify 배포 작업 중 오류를 확인 할 수 있다고 한다. Netlify는 yarn 기반이기 때문에 가급적이면 yarn으로 설치하길 권장한다.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;공부한 내용을 정리하는 공간으로 학습 중 습득한 내용이 정확하지 않은 정보를 포함할 수 있어 추후 발견시 수정하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</content:encoded></item></channel></rss>